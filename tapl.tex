\documentclass{article}

\usepackage{ctex}
\usepackage{tikz}
\usetikzlibrary{cd}

%冲突nthm
%\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} %for :=
\usepackage{stmaryrd} %for double square bracket

%\usepackage{unicode-math}
%\usepackage{chngcntr}
\usepackage{hyperref} %url
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }


\usepackage[textwidth=18cm]{geometry} % 设置页宽=18

\usepackage{blindtext}
\usepackage{bm}
\parindent=0pt
\setlength{\parindent}{2em} 
\usepackage{indentfirst}

\usepackage{listings}
%\usepackage{minted}% hightlighting

\usepackage{proof} % infer

\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\color{blue}\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[hang]{\color{red}\Large\bfseries}{}{0em}{}
%\setcounter{secnumdepth}{1} %section 序号


\usepackage[thmmarks, thref, amsmath]{ntheorem}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}

\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{exercise}{Exercise}[section]
\newtheorem{annotation}[theorem]{Annotation}

\theoremheaderfont{\itshape}
\theorembodyfont{\upshape}
\newtheorem{case}{Case}

\theoremstyle{nonumberplain}
\theoremheaderfont{\scshape}
\theorembodyfont{\upshape}
\theoremsymbol{\scshape Q. E. D.}
\theorempostwork{\setcounter{case}{0}}
\newtheorem{proof}{Proof}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{case}{Case}
%\newtheorem{subcase}{Case}
%\numberwithin{subcase}{case}

\newcommand*{\xfunc}[4]{{#2}\colon{#3}{#1}{#4}}
\newcommand*{\func}[3]{\xfunc{\to}{#1}{#2}{#3}}

\newcommand\Set[2]{\{\,#1\mid#2\,\}} %集合
\newcommand\SET[2]{\Set{#1}{\text{#2}}} %

\newcommand{\inl}[1]{\ensuremath{\text{inl}~#1}}
\newcommand{\inr}[1]{\ensuremath{\text{inr}~#1}}
\newcommand{\fold}[1]{\ensuremath{{fold}_{#1}}}
\newcommand{\unfold}[1]{\ensuremath{{unfold}_{#1}}}
\newcommand{\lam}[2]{\ensuremath{\lambda #1\ldotp~ #2}} %lamx.y
\newcommand{\pair}[1]{\ensuremath{\left\langle#1\right\rangle}}
\newcommand{\projone}[1]{\ensuremath{#1.1}}
\newcommand{\projtwo}[1]{\ensuremath{#1.2}}
\newcommand{\caseof}[3]{\ensuremath{{\textbf{case}}~#1~{\textbf{of}}~\inl{x_1}\mapsto #2\mid\inr{x_2}\mapsto #3}}
\newcommand{\Lam}[2]{\ensuremath{\Lambda #1\ldotp #2}}
\newcommand{\pack}[3]{\ensuremath{{pack}~\pair{#1,#2}~{as}~#3}}
\newcommand{\unpack}[4]{\ensuremath{{unpack}~#1~{as}~\pair{#2,#3}~{in}~#4}}
\newcommand{\assign}[2]{\ensuremath{#1~\coloneqq~#2}}
\newcommand{\singletype}[1]{\text{#1}}
\newcommand{\termtype}[2]{\ensuremath{#1:#2}}
\newcommand{\type}[3]{\ensuremath{ \left\{#1:#2\relmiddle|#3 \right\}}}
\newcommand{\matgen}[2]{\ensuremath{\mu #1\ldotp#2}} %ux.y
\newcommand{\mat}[0]{\matgen{\alpha}{\tau}} %ua.t
\newcommand{\fatgen}[2]{\ensuremath{\forall #1\ldotp#2}}
\newcommand{\fat}[0]{\fatgen{\alpha}{\tau}}
\newcommand{\eatgen}[2]{\ensuremath{\exists #1\ldotp#2}}
\newcommand{\eat}[0]{\eatgen{\alpha}{\tau}}
\newcommand{\fatgent}[2]{\ensuremath{\trgb{\forall} #1\ldotp#2}}
\newcommand{\fatt}[0]{\fatgent{\alpt}{\tat}}
\newcommand{\eatgent}[2]{\ensuremath{\trgb{\exists} #1\ldotp#2}}
\newcommand{\eatt}[0]{\eatgent{\alpt}{\tat}}

\newcommand{\fail}[0]{\mi{fail}}

\newcommand{\bnfdef}[0]{\ensuremath{\mathrel{::=}}} %::=
\newcommand{\term}[1]{\ensuremath\mathsf{#1}}
\newcommand{\true}{\term{true}}
\newcommand{\false}{\term{false}}
\newcommand{\ifelse}[3]{\ensuremath{\textbf{if}~#1~\textbf{then}~#2~\textbf{else}~#3}}
\newcommand{\succt}[1]{\term{succ}~#1}
\newcommand{\pred}[1]{\term{pred}~#1}
\newcommand{\iszero}[1]{\term{iszero}~#1}
\newcommand{\seq}[2]{#1;#2}
\newcommand{\subtyp}[2]{#1<:#2}


\newcommand{\redt}[1]{\textcolor{red}{#1}}
\newcommand{\bluet}[1]{\textcolor{blue}{#1}}
\newcommand{\abracket}[1]{\ensuremath{\left< #1 \right>}}
\newcommand{\dbracket}[1]{\ensuremath{\left\llbracket\,\vcenter{\hbox{$#1$}}\,\right\rrbracket}}

\begin{document}
\title{Types and Programming Language}
\author{枫聆}
\maketitle
\tableofcontents

\newpage
\section{Introduction}

\begin{definition}
\rm A {\color{red} type system} is a tractable syntactic method for proving the absence of certain program behaviors by classlying phrases according to the kinds of value they compute.
\end{definition}

{\color{blue} type system是一种用于证明某些确定的程序行为不会发生的方法，它怎么做呢？通过它们计算出值的类型来分类, 有点抽象... 我想知道the kinds of value they compute是什么？ 如何分类？ 分类之后接下来该怎么做？}

\begin{annotation}
\rm Being static, type systems are necessarily also {\color{red}conservative}: they can categorically prove the absence of some bad program behaviors， but they cant prove their presence.
\end{annotation}

\lstset{language=C,
    basicstyle=\ttfamily,
    keywordstyle=\bfseries,
    showstringspaces=false,
    morekeywords={include, printf}
}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=2, numbersep=5pt}

\begin{example}
\rm
\begin{lstlisting}
if <complex test> then 5 else <type error>
\end{lstlisting}
{\color{blue} 上面这个annotation在说type system只能证明它看到的一些bad program behavior不会出现，但是它们可能会reject掉一些runtime time阶段运行良好的程序，例如在runtime阶段上面的else可能永远都不会进. 即type system无法证明它是否真的存在}.
\end{example}

\newpage
\section{Untyped Systems}

\subsection{Syntax}

\begin{definition}
\rm The set of terms is the smallest set $\mathcal{T}$ such that 
\begin{enumerate}
	\item $\{\text{true},\text{false},0\} \subseteq \mathcal{T}$;
	\item if $t_1 \in \mathcal{T}$, then $\{\text{succ}\ t_1, \text{pred}\ t_1, \text{iszero}\ t_1\} \subseteq \mathcal{T}$;
	\item if $t_1 \in \mathcal{T}, t_2 \in \mathcal{T}, t_3 \in \mathcal{T}$, then $\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!} \in \mathcal{T}$.
\end{enumerate}
\end{definition}

\begin{definition}
\rm The set of terms is defined by the following rules:
$$
\begin{array}{ccc}
\text{true} \in \mathcal{T}  & \text{false} \in \mathcal{T} & 0 \in \mathcal{T} \\
\infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} & \infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} & \infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} \\
& \infer{\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!}}{ t_1 \in \mathcal{T} & t_2 \in \mathcal{T} & t_3 \in \mathcal{T}} &\\ 
\end{array}
$$
\end{definition}

\begin{definition}
\rm For each natural number $i$, define a S(X) as follow:
$$
\begin{aligned}
S_0(X)  &= X \\
S_1(X)  &= \Set{\text{succ}\ t,\text{prev}\ t,\text{iszero}\ t }{t \in X} \cup \Set{\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!}}{t_1,t_2,t_3 \in X} \\
&\vdots \\
S_{i+1}(X) &= S(S_i(X)).
\end{aligned}
$$
\end{definition}

\begin{proposition}
\rm $\mathcal{T} = \bigcup_{i = 0}^{\omega} S_i(\{\text{true},\text{false},0\})$.
\end{proposition}

\begin{proof}
我们设$\bigcup_{i = 0}^{\omega} S_i(\{\text{true},\text{false},0\}) = S$和$\{\text{true},\text{false},0\} = T$，证明过程分两步走(1)$S$ follow Definition2.1 (2) $S$ is smallest.

proof (1). $\{\text{true},\text{false},0\} \in S$这是显然的. 若$t_1 \in S$，那么$t_1 \in S_i(T)$，考虑$\text{succ}\ t_1, \text{pred}\ t_1, \text{iszero}\ t_1 \in S_{i+1}(T)$.  同理Definiton2.1(3).

proof (2). 考虑任意follow Definition2.1的集合$S'$，我们需要证明$S \subseteq S'$.  我们考虑任意的$S_i \subseteq S$，若都有$S_i \subseteq S'$，那么则有$S \subseteq S'$. 这里我们使用induction来证明，首先有$S_0(T) \subseteq S'$，假设$S_n(T) \subseteq S'$. 那么考虑$S_{n+1}(T) = S(S_n(T))$，任意的$t_1，t_2, t_3 \in S_n(T)$，那么Definition2.1(1)(2)(3)得到的结果都是属于$S'$，因此$S_{n+1}(T) \subseteq S'$.  
\end{proof}

\begin{definition}
\rm The \redt{depth} of a term $t$ is the smallest $i$ such that $t \in S_i(X)$. 
\end{definition}

\begin{definition}
\rm If a term $\term{t} \in S_i(X)$, then all of its \redt{immediate subterms} must be in $S_{i-1}(X)$. 
\end{definition}


\begin{theorem}
\rm \redt{Structural induction} Suppose $P$ is a predicate on terms. If for each term $\term{s}$, given $P(\term{r})$ for all immediate subterms $\term{r}$ of $\term{s}$, we can show $P(\term{s})$, then $P(\term{s})$ holds for all $\term{s}$. 
\end{theorem}



\subsection{Induction}


\newpage
\subsection{Semantic Styles}

%https://www.zhihu.com/question/23861885
\begin{annotation}
\rm 有三种方法来形式化语义:
\begin{enumerate}
	\item Operational semantics(操作语义) 定义程序是如何运行的？ 所以你需要一个abstract machine来帮助解释，之所以abstract是因为它里面的mechine code就是the term of language. 其中又分为两种类型，big-step和small-step.
	\item Denotational semantics(指称语义) 就是给定一个semantic domain和一个interpretaion function，通过这个function把term映射到semantic domain里面，这个domain里面可能是一堆数学对象. 它的优势是对求值进行抽象，突出语言的本质. 我们可以在semantic domain里面做运算，只要interpretation function建立的好，运算结果可以表征程序本身的性质.
	\item Axiomatic semantics(公理语义) 拿axioms堆起来的程序？ 类似Hoare logic.
	\item Alegbraic semantics(代数语义) 把程序本身映射到某个代数结构上，转而研究这个代数?
\end{enumerate}
\end{annotation}

\newpage
\subsection{Evaluation}

\begin{annotation}
\rm 这一章在讲operational semantic of boolean expression, 这个过程会清晰的告诉你我们求值的结果是什么？当我们对term求值时，term之间的转换规则应该是什么？ 既然有了转换，那么一定有终止的时候，这个终止的时刻就是我们求值的结果，那我们要问什么时候停止呢？ 开头的表格告诉了关于前面这些问题的答案. 当然有一些东西也没有出现在表格里面，但是它们同样重要，例如不能在对false，true，0这些东西再求值；求值的顺序等等.
\end{annotation}


\begin{definition}
\rm An instance of an inference rule is obtained by consistently replacing each metavariable by the same term in the rule’s conclusion and all its premises (if any).

{\color{blue} 一个推导规则的实例，就是把里面的metavariable替换成具体的terms，但是一定需要注意对应关系}.
\end{definition}


\begin{definition}
\rm Evaluation relations: 一步求值 (基本evaluation relation)；多步求值 (evaluation relation的传递闭包产生的新的relation， 这个relation包含原来的所有evaluation relation);
\end{definition}


\begin{definition}
\rm A term t is in normal form if no evaluation rule applies to it.

{\color{blue} 范式是一个term无法继续求值的状态}.
\end{definition}

\begin{definition}
\rm A closed term is stuck if it is in normal form but not a value, we often call it neutral form.

{\color{blue} 受阻项是一种特殊的范式，这个范式不是一个合法的值}.
\end{definition}



\newpage
\subsection{The Untyped Lambda-Calculus}

\begin{annotation}
\rm {\color{red} 过程抽象} Procedural (or functional) abstraction is a key feature of essentially all pro-gramming languages
\end{annotation}

\begin{definition}
\rm {\color{red} $\lambda$演算的定义} The lambda-calculus (or -calculus) embodies this kind of function defi-nition and application in the purest possible form. In the lambda-calculus everything is a function: the arguments accepted by functions are themselves functions and the result returned by a function is another function.

The syntax of the lambda-calculus comprises just three sorts of terms.
$$
\begin{aligned}
\term{t} \bnfdef & \\
&\ \term{x} \\
&\ \lam{x}{\term{t}} \\
&\ \term{t}\ \term{t}.
\end{aligned}
$$
A variable $\term{x}$ by itself is a term; the abstraction of a variable $\term{x}$ from a term $\term{t_1}$, written $\lam{x}{t_1}$, is a term; and the application of a term $\term{t_1}$ to another term $\term{t_2}$, written $\term{t_1}\ \term{t_2}$, is a term.

{\color{blue} 在 pure lambda-calculus里面所有的terms都是函数，第一个term表示变量，第二个term表示abstraction，第三个term表示application. 言下之意一个lambda函数的参数和返回值也都是函数}. 
\end{definition}

\begin{definition}
\rm {\color{red}两个重要的约定} First, application associates to the left, means
$$
\term{s}~\term{t}~\term{u} = (\term{s}~\term{t})~\term{u}.
$$
Second, the bodies of abstractions are taken to extend as far to the right
as possible.
$$
\lam{x}{\lam{y}{x~y~x}} = \lam{x}{(\lam{y}{((x~y)~x)})}.
$$

{\color{blue} 第一个是说函数的apply操作是左结合，第二是说lambda函数的抽象体尽量向右扩展}.
\end{definition}

\begin{definition}
\rm {\color{red} 作用域scope} An occurrence of the variable x is said to be {\color{red} bound} when it occurs in the body $\term{t}$ of an abstraction $\lam{x}{\term{t}}.$(More precisely, it is bound by this abstraction.
Equivalently, we can say that $\lambda x$ is a binder whose scope is $\term{t}$.) An occurrence of $x$ is {\color{red} free} if it appears in a position where it is not bound by an enclosing abstraction on $x$. i.e. $x$ in $\lam{y}{x\ y}$ and $x\ y$ are free. 

A term with no free variables is said to be {\color{red} closed}; closed terms are also called {\color{red}combinators}. The simplest combinator, called the identity function,
$$
\term{id} = \lam{x}{x}.
$$
\end{definition}

\begin{definition}
\rm {\color{red} $\alpha$等价} A basic form of equivalence, definable on lambda terms, is alpha equivalence. It captures the intuition that the particular choice of a bound variable, in an abstraction, does not (usually) matter. 
$$
\lam{x}{x} \cong \lam{y}{y}
$$

{\color{blue} 简而言之，同时对一个lambda函数替换所有bound variable得到的term是等价的, $\alpha$变换在进行$\beta$规约的时候，用于解决变量名冲突特别有用）}.
\end{definition}

\begin{definition}
\rm {\color{red} 操作语义} Each step in the computation consists of rewriting an application whose left-hand component is an abstraction, by substituting the right-hand component for the bound variable in the abstraction's body.Graphically, we write
$$
(\lam{x}{\term{t_{12}}})~\term{t_2} \rightarrow \left[ x \mapsto \term{t_2} \right] \term{t_{12}},
$$
where $\left[ x \mapsto \term{t_2} \right]$ means "the term obtainted by replacing all free occurences of $x$ in $\term{t_{12}}$ by $t_2$". 
\end{definition}

\begin{definition}
\rm {\color{red} 可约表达式} A term of the form $(\lam{x}{\term{t_{12}}})~\term{t_2}$ is called {\color{red} redex} (reducible expression), and the operation of rewriting a redex according to the above rule is called {\color{red} $\beta$-reduction}.
\end{definition}

%https://en.wikipedia.org/wiki/Evaluation_strategy
\begin{definition}
\rm {\color{red} 几种规约策略} Each strategy defines which redex or redexes in a term can fire on the next step of evaluation. 
\begin{enumerate}
	\item Undering {\color{red} full $\beta$-reduction}, any redex may be reduced at any time. i.e., consider the term
	$$
	(\lam{x}{x})~((\lam{x}{x})~(\lam{z}{(\lam{x}{x})~z})),
	$$
	we can write more readably as $\term{id}~(\term{id}(\lam{z}{\term{id}}~z))$. This term contains three redexes:
	$$
	\begin{aligned}
	\underline{\term{id}~(\term{id}~(\lam{z}{\term{id}}~z))} \\
	\term{id}~(\underline{\term{id}~(\lam{z}{\term{id}}~z)}) \\
	\term{id}~(\term{id}~(\lam{z}{\underline{\term{id}~z}}))
	\end{aligned}
	$$
	under full $\beta$-reduction, we might choose, for example, to begin with the innermost index, then do the one in the middle, then the outermost:
	$$
	\begin{aligned}
	&\term{id}~(\term{id}~(\lam{z}{\underline{\term{id}~z}})) \\
	\rightarrow & \term{id}~(\underline{\term{id}~(\lam{z}{z})}) \\
	\rightarrow & \underline{\term{id}~(\lam{z}{z})} \\
	\rightarrow & \lam{z}{z} \\
	\nrightarrow
	\end{aligned}
	$$
	\item Undering the {\color{red} normal order} strategy, the leftmost, outermost redex is always reduced first. Under this strategy, the term above would be reduced as follows
	$$
	\begin{aligned}
	& \underline{\term{id}~(\term{id}~(\lam{z}{\term{id}~z}))} \\
	\rightarrow & \underline{\term{id}~(\lam{z}{\term{id}}~z)} \\
	\rightarrow & \lam{z}{\underline{\term{id}~z}} \\
	\rightarrow & \lam{z}{z} \\
	\nrightarrow
	\end{aligned}
	$$
	\item The {\color{red} call by name} strategy is yet more restrictive, allowing no reductions inside abstractions. 
	$$
	\begin{aligned}
	& \underline{\term{id}~(\term{id}~(\lam{z}{\term{id}~z}))} \\
	\rightarrow & \underline{\term{id}~(\lam{z}{\term{id}}~z)} \\
	\rightarrow & \lam{z}{\term{id}~z} \\
	\nrightarrow
	\end{aligned}
	$$
	\item Most languages use a {\color{red} call by value} strategy, in which only outermost redexes are reduced and where a redex is reduced only when its right-hand side has already been reduced to a value-a term that is finished computation and cannot be reduced and further.
	$$
	\begin{aligned}
	& \term{id}~\underline{(\term{id}~(\lam{z}{\term{id}~z}))} \\
	\rightarrow & \underline{\term{id}~(\lam{z}{\term{id}}~z)} \\
	\rightarrow & \lam{z}{\term{id}~z} \\
	\nrightarrow
	\end{aligned}
	$$
\end{enumerate}

{\color{blue} 注意call by name和 call by value的区别，call by name是在$\lambda$函数调用前不对参数进行规约而直接替换到函数body内，换言之如果一个参数不会被用到，那么它永远都不会被evaluated，call by value是其对立情况，先对参数进行规约}.

{\color{red} Evaluation strategies are used by programming languages to determine two things—when to evaluate the arguments of a function call and what kind of value to pass to the function}.
\end{definition}

\begin{definition}
\rm Given lambda abstraction $\lam{x}{e}$, then the \redt{$\eta$-conversation} of it as follow
$$
\lam{y}{(\lam{x}{e})~y}
$$
where $y$ is not in $e$.  
\end{definition}

\newpage
\subsection{Programming in the Lambda-Calculus}

\begin{definition}
\rm {\color{red} 高阶函数} A higher order function is a function that takes a function as an argument, or returns a function.
$$
f^{\circ n} = \underbrace{f \circ f \circ \cdots \circ f}_{n~\text{times}}.
$$
\end{definition}


\begin{annotation}
\rm Define $\circ$ itself as a function:
$$
\circ = \lam{f}{\lam{g}{\lam{x}{f(g(x))}}}. 
$$
So function composition can be denoted by
$$
\circ~f~g  = \lam{x}{f(g(x))}.
$$
\bluet{非常漂亮}. 
\end{annotation}

\begin{annotation}
\rm {\color{red} 多参数柯里化} Motivation is that the lambda-calculus provides no built-in support for multi-argument functions. The solution here is higher-order functions. 

Instead of writing $f = \lam{(x,y)}{\term{s}}$, as we might in a richer programming language, we write $f = \lam{x}{\lam{y}{\term{s}}}$. we then apply $f$ to it arguments one at times, write $f~v~w$, which reduces to
$$
f~v~w \rightarrow \lam{y}{\left[ x \mapsto v \right] s} \rightarrow \left[ x \mapsto v \right]\left[ y \mapsto w \right]s.
$$
This transformation of multi-arguments function into higher-order function is called {\color{red} currying} in honor of Haskell Curry,a contemporary of Church.
\end{annotation}

\begin{annotation}
\rm {\color{red} Church形式的布尔代数} Define the terms \textbf{tru} and \textbf{fls} as follows:
$$
\begin{aligned}
\text{tru} &= \lam{t}{\lam{f}{t}}\\
\text{fls} &= \lam{t}{\lam{f}{f}}\\
\end{aligned}
$$
The terms \textbf{tru} and \textbf{fls} can be viewed as representing the boolean values“true” and “false,” then define a combinator \textbf{test} with the property that $\text{test}~b~v~w$ reduces to $v$ when $b$ is \textbf{tru} and reduces $w$ when $b$ is \textbf{fls}.
$$
\text{test}~= \lam{l}{\lam{m}{\lam{n}{l~m~n}}};
$$  
The \textbf{test} combinator does not actually do much: $test~b~v~w$ reduces to $b~v~w$. i.e., the term $\text{test}~\text{tru}~v~w$ reduces as follows:
$$
\begin{aligned}
&\text{test}~\text{tru}~v~w \\
= & \text{tru}~v~w \\
\rightarrow & \underline{(\lam{t}{\lam{f}{t}})~v}~w \\
\rightarrow & \underline{(\lam{f}{v})~w} \\
\rightarrow & v.
\end{aligned}
$$
We can also define boolean operator like logical conjunction as functions:
$$
\text{and} = \lam{b}{\lam{c}{b~c~\text{fls}}} = \lam{b}{\lam{c}{b~c~b}} 
$$
Define logical \textbf{or} and \textbf{not} as follows:
$$
\begin{aligned}
\text{or} &= \lam{b}{\lam{c}{b~\text{tru}~c}} = \lam{b}{\lam{c}{b~b~c}} \\
\text{not} &= \lam{b}{b~\text{fls}~\text{tru}} \\
\text{xor} &= \lam{b}{\lam{c}{b~(\text{not}~c)~c}}
\end{aligned}
$$ 
\end{annotation}

$$
\begin{aligned}
\text{tru} &= \lam{t}{\lam{f}{t}}\\
\text{xor} &= \lam{a}{\lam{b}{a~(\text{not}~b)~b}} \\
\text{xor}~\text{tru}~b &= \text{tru}~(\text{not}~b)~b \\
						&= \text{not}~b 
\end{aligned}
$$

\begin{annotation}
\rm {\color{red} 有序对} Using booleans, we can encode pairs of values as terms.
$$
\begin{aligned}
\text{pair} &= \lam{f}{\lam{s}{\lam{b}{b~f~s}}} \\
\text{fst} &= \lam{p}{p~\text{tru}} \\
\text{snd} &= \lam{p}{p~\text{fls}} \\
\end{aligned}
$$

{\color{blue} pair变成了一个函数，它可以接收一个tru或者fls来返回第一个值或者第二个值，fst和snd就是pair的一个applying过程，比较有趣}.
\end{annotation}

\begin{annotation}
\rm {\color{red}Church形式的序数} Define the Church numerals as follows
$$
\begin{aligned}
c_0 &=  \lam{s}{\lam{z}{z}} \\
c_1 &=  \lam{s}{\lam{z}{s~z}} \\
c_2 &=  \lam{s}{\lam{z}{s~(s~z)}} \\
c_3 &=  \lam{s}{\lam{z}{s~(s~(s~z))}}  \\
&\cdots
\end{aligned}
$$
这里我们使用高阶函数来描述这一性质
\begin{center}
\begin{tabular}{r |l |l }
 \text{Number} & \text{Function definition} & \text{Lambda expression} \\
\hline
 0 & $0~f~x = x$  & $0 = \lam{f}{\lam{x}{x}}$ \\ 
 1 & $1~f~x = f~x$ & $1 = \lam{f}{\lam{x}{f~x}}$ \\  
 2 & $2~f~x = f~(f~x)$ & $2 = \lam{f}{\lam{x}{f~(f~x)}}$ \\
 3 & $3~f~x = f~(f~(f~x))$ & $3 = \lam{f}{\lam{x}{f~(f~(f~x))}}$ \\
 \vdots & \vdots & \vdots \\
 n & $n~f~x = f^n~x$ & $n = \lam{f}{\lam{x}{f^{\circ n}~x}}$ \\
\end{tabular}
\end{center}

{\color{blue} 参考皮亚诺公理，对应这里我们构建自然数需要有一个$0$和一个后继函数$f$. 你会注意到$c_0$和\textbf{fls}是同一个term，常规编程语言里面很多情况下$0$和false确实也是一个东西}.
\end{annotation}


\begin{annotation}
\rm {\color{red}Church形式序数的运算符} We can define the successor function on Church numerals as follows
$$
\text{succ} = \lam{n}{\lam{s}{\lam{z}{s~(n~s~z)}}}
$$

{\color{blue} 注意这里的后继函数接受对象是一个Church numeral，从而返回新的Church numeral，和我们构造Church number中的后继不是一个东西，它的作用就是让对应具体的数再复合一次$f$. 因此分解一下上面的apply过程，首先是$(n~s~z)$得到相对应的数，然后在对它复合一次$f$}.

另外一种形式
$$
\text{succ} = \lam{n}{\lam{s}{\lam{z}{n~s~(s~z)}}}
$$
{\color{blue} 这个方式也很巧妙，相当于把$0' = 0 + 1$作为新的零元}.
\end{annotation}

\begin{annotation}
\rm The addition of Church numerals can be preformed by a term \textbf{plus} that takes two Church numerals $m$ and $n$, as arguments, and yields another Church numeral. 
$$
\text{plus} = \lam{m}{\lam{n}{\lam{s}{\lam{z}{m~s~(n~s~z)}}}}
$$

{\color{blue} 这里遵循函数复合的结合律$f^{\circ(m+n)}(z) = f^{\circ m}(f^{\circ n}(x))$，相对于把其中的一个Church number对应的具体数当做了另一个Church numeral的zero}.
\end{annotation} 

\begin{annotation} \rm
$$
\text{times} = \lam{m}{\lam{n}{m~(\text{plus}~n)~c_0}}
$$

{\color{blue} 这个就非常有趣了，这里先固定$m$，把它succ设为$\text{plus}~n$和zero设为$c_0$，相当于$(\text{plus}~n)^m(c_0)$}.

另一种更简洁的形式:
$$
\text{times} = \lam{m}{\lam{n}{\lam{s}{\lam{z}{m~(n~s)~z}}}}
$$
{\color{blue} 这里的$(n~s)$变成了一个特殊abstraction $s^{\circ n} = \lam{z}{s(s(\cdots(s~z)\cdots))}$，它并不是一个标准的$\text{succ}$形式}
\end{annotation}

\begin{annotation} \rm 
$$
\text{exp} = \lam{m}{\lam{n}{n~m}}
$$

推一个来看看，注意其中的几次$\alpha$变换，避免产生变量名的冲突.
$$
\begin{aligned}
\text{exp}~c_3~c_2 &= c_2~c_3 \\
			&= (\lam{s}{\lam{z}{s~(s~z)}})~c_3 \\
			&= \lam{z}{c_3~(c_3~z)} \\
	{\color{red}\leadsto_\alpha} &= \lam{z}{(\lam{f}{\lam{x}{f~(f~(f~x))}})~((\lam{f}{\lam{x}{f~(f~(f~x))}})~z)} \\
			&= \lam{z}{(\lam{f}{\lam{x}{f~(f~(f~x))}})~(\lam{x}{z~(z~(z~x))})} \\
	{\color{red}\leadsto_\alpha} &= \lam{z}{(\lam{f}{\lam{x}{f~(f~(f~x))}})~(\lam{g}{z~(z~(z~g))})} \\
			&= \lam{z}{\lam{x}{(\lam{g}{z~(z~(z~g))})~((\lam{g}{z~(z~(z~g))})~((\lam{g}{z~(z~(z~g))})~x))}} \\
			&= \lam{z}{\lam{x}{(\lam{g}{z~(z~(z~g))})~((\lam{g}{z~(z~(z~g))})~(z~z~z~x))}}\\
			&= \lam{z}{\lam{x}{(\lam{g}{z~(z~(z~g))})~(z~z~z~z~z~z~x)}} \\
			&= \lam{z}{\lam{x}{z~z~z~z~z~z~z~z~z~x}} \\
			&= \lam{s}{\lam{z}{s~s~s~s~s~s~s~s~s~z}} \\
			&= c_9 \\	
\end{aligned}
$$
\end{annotation}

\newpage
\subsection{Normal Forms}

\begin{annotation}
\rm 前面提到的neural term-"neutral terms contain a free variable at a 'head' position"，它是对normal form更细致的一种刻画，形如$\term{x}~\term{y}$，其中$\term{x}$是一个free variable，而$\term{y}$是一个lambda abstraction. 
\end{annotation}

\begin{definition}
\rm In untyped lambda calculus, the neutral terms and the normal form are generated in the following rules.
$$
\begin{array}{ccccccc}
\infer{\lam{\term{x}}{\term{t}}~\textsl{nf}}{&\term{t}~\textsl{nf}&} &&
\infer{\term{t}~\textsl{nf}}{&\term{t}~\textsl{ne}&} &&
\infer{\term{t}_1~\term{t}_2~\textsf{ne}}{&\term{t}_1~\textsl{ne}& \term{t}_2~\textsl{nf}&} && \infer{\term{x}~\textsf{ne}}{& &}
\end{array}
$$
\end{definition}


\begin{annotation}
\rm 定义上述normal form的generator本想是根据它们来证明一些依赖normal form的命题，例如false和true的刻画"if $\vdash e:\alpha \to (\alpha \to \alpha)$ and $e$ is normal form, then $e = true$ or $e = false$"，对$e$使用normal form structure induction，仅仅使用上面第一个inference rule，实际上就可以了. 注意normal form的定义并不依赖type system，显然neutral term这种东西在STLC根本不可能出现... 
\end{annotation}

\newpage
\subsection{Recursion}

\begin{annotation}
\rm 首先经历几个思考recurison历程. 首先给出一个标准recurison过程，阶乘过程
$$
\text{fact}~\overline{n} = \text{if}~(\iszero~\overline{n})(\overline{1})~\text{then}~(\text{mult}~\overline{n}~(\text{fact}~(\text{pred}~\overline{n}))). 
$$
其中$\overline{n}$代表church number. 因此$\text{fact}$表示的abstraction为
$$
\text{fact} = \lam{n}{\text{if}~(\iszero~n)(\overline{1})~\text{then}~(\text{mult}~n~(\text{fact}~(\text{pred}~n)))}
$$
这里我们只有一个等式，那么我们应当如何准确地给出$\text{fact}$的定义呢？ 如果我们尝试给左边的$\text{fact}$提出来，即
$$
\text{fact} = (\lam{f}{\lam{n}{\text{if}~(\iszero~n)(\overline{1})~\text{then}~(\text{mult}~n~(f(\text{pred}~n)))}})~\text{fact}
$$
将左边括号里面的abstraction看做一个函数，那么$\text{fact}$实际上就是它的一个fixed point. 我们的下一个目标就是想办法构造出这个函数的不动点，如果这个不动点正好就是我们需要的$\text{fact}$那就太好了.
\end{annotation}


\begin{definition}
\rm A \redt{self-applicatin abstraction} is 
$$
\omega = \lam{x}{x~x}.
$$
The \redt{divergent omega combinator} is 
\[
	\Omega = \omega \omega = (\lam{x}{x~x})~(\lam{x}{x~x}).
\]
\end{definition}

\begin{definition}
\rm A  call-by-name \redt{Y combinator} is
$$
\mathbf{Y} = \lam{f}{(\lam{x}{f~(x~x)})~(\lam{x}{f~(x~x)})}.
$$
\end{definition}

\begin{theorem}
\rm For all abstractions $F \in \Lambda$, we have 
$$
\mathbf{Y}F = F(\mathbf{Y}F)
$$
\end{theorem}

\begin{proof}
只需要对$\mathbf{Y}F$做两次application即可
$$
\begin{aligned}
\mathbf{Y}F &= (\lam{x}{F~(x~x)})~(\lam{x}{F~(x~x)}) \\
&= F((\lam{x}{F~(x~x)})~(\lam{x}{F~(x~x)}) \\
&= F(\mathbf{Y}F). 
\end{aligned}
$$
\end{proof}

\begin{annotation}
\rm 我们将使用$\mathbf{Y}$ combinator继续$\text{fact}$的definition，我们使\[F = (\lam{f}{\lam{n}{\text{if}~(\iszero~n)(\overline{1})~\text{then}~(\text{mult}~n~(f(\text{pred}~n)))}}).\]由前述的theorem，现在我们有一个fixed point $\mathbf{Y}F$. 我们使$\text{fact} = \mathbf{Y}F$，显然有
$$
\begin{aligned}
\text{fact}~n &= \mathbf{Y}F~n \\
&= F({Y}F)~n \\
&= \text{if}~(\iszero~n)(\overline{1})~\text{then}~(\text{mult}~n~(\mathbf{Y}F(\text{pred}~n))) \\
&= \text{if}~(\iszero~n)(\overline{1})~\text{then}~(\text{mult}~n~(\text{fact}(\text{pred}~n))) 
\end{aligned}
$$
当我们思考$\mathbf{Y}F$是不是我们想要的那个fixed point呢？ 实际上它就是$\text{fact}$的准确定义. 这个问题我们这样思考: 对于每一个church number $\overline{n}$, $\text{fact}$都有对应的形式$\text{fact}_{\overline{n}}$, 展开$\mathbf{Y}F \overline{n} = F^n(\mathbf{Y}F) \overline{n}	$也可以得到相同的结果. 那么整个定义就是well-defined. 
\end{annotation}

\begin{example}
\rm 如果$F = \lam{x}{x}$, 我们可以得到什么东西呢？ 所有term $x$都是其fixed point. 即
$$
x = \lam{x}{x} x  \Rightarrow x = x
$$
Nothing we have done. 
\end{example}


\newpage
\section{Simple Types}

\subsection{Typed Arithmetic Expressions}

\begin{definition}
\rm The typing relation for arithmetic expressions, written
$$
\termtype{\term{t}}{\text{T}}
$$
is defined by a set of inference rules assigning types to terms.
$$
\begin{array}{c}
\termtype{\true}{\text{bool}} \\
\termtype{\false}{\text{bool}} \\[0.5em]
\infer{\termtype{\ifelse{\term{t}_1}{\term{t}_2}{\term{t}_3}}{\text{T}}}{\termtype{\term{t}_1}{\text{bool}} & \termtype{\term{t}_2}{\text{T}} & \termtype{\term{t}_3}{\text{T}}} \\
\termtype{\term{0}}{\text{nat}} \\[0.5em]
\infer{\termtype{\succt{\term{t}_1}}{\text{nat}}} {\termtype{\term{t}_1}{\text{nat}}}\\[0.5em]
\infer{\termtype{\pred{\term{t}_1}}{\text{nat}}} {\termtype{\term{t}_1}{\text{nat}}}\\[0.5em]
\infer{\termtype{\iszero{\term{t}_1}}{\text{bool}}} {\termtype{\term{t}_1}{\text{nat}}}\\
\end{array} 
$$
\end{definition}

\begin{annotation}
\rm 注意分支terms中的$\text{T}$表示任意的types即可能包括$\text{bool}$和$\text{nat}$. 理论上两个分支的表达式的type可以不一样，但是这一样以来似乎就不是well-typed, 处理这样的情况需要等到我们学习更多的类型的type之后才能来重新构造. 
\end{annotation}

\begin{annotation}
\rm \bluet{使用inference rule来描述type是为了更方便地证明inductive theorem}.
\end{annotation}

\begin{definition}
\rm A term $\term{t}$ is \redt{typbale or well typed} if there is some $\text{T}$ such that $\termtype{\term{t}}{\text{T}}$. If $\term{t}$ is typable, then its type is unique(\redt{uniquness of types}). 
\end{definition}

%why
\begin{annotation}
\rm 这里很重要是理解如果给定一个type relation $\termtype{\term{t}}{\text{T}}$，那么肯定是由上述inference rule推导出来的，所以我们会经常看到从conclude推premise的过程，也就是寻找合适的inference rule反向推导，这个过程我们称其为\bluet{derivation}，其中反向寻找合适的inference rule的方法是利用了所谓inversion lemma. 
\end{annotation}

\begin{theorem}
\rm \redt{progress} A well-typed term is not stuck.
\end{theorem}

\begin{proof}
\rm 我们利用structural induction来证一下progress. 首先基本的terms $\false, \true, 0, \succt{\term{nv}}$都是明显的values, 其中$\term{nv}$表示一个numeric value. 

\begin{case}
$\term{t} = \ifelse{\term{t}_1}{\term{t}_2}{\term{t}_3} ~~~~\text{hyp}:~ \term{t}_1 = \text{bool} ~~ \term{t}_2 = \text{T} ~~ \term{t}_3 = \text{T}.$

当$\term{t}_1 = \true$或者$\term{t}_1 = \false$时，我们对$\term{t}$一步evaluation得到$\term{t}_2$或者$\term{t}_3$.  另外当$\term{t}_1 \to \term{t}_1'$时，我们也可以得到$\term{t} \to \ifelse{\term{t}_1'}{\term{t}_2}{\term{t}_3}$. 
\end{case} 

\begin{case}
$\term{t} = \succt{\term{t}_1} ~~~ \text{hyp}:~ \term{t}_1 = \text{nat}.$

设当$\term{t}_1 = \text{nv}$时，那么$\succt{\term{t}_1}$还是一个numeric value. 另外当$\term{t}_1 \to \term{t}_1'$，我们也可以得到$\term{t} \to \succt{\term{t}_1'}$
\end{case} 

\begin{case}
$\term{t} = \pred{\term{t}_1}~~~ \term{t}_1 = \text{nat}.$

同上.
\end{case} 

\begin{case}
$\term{t} = \iszero{\term{t}_1}~~~ \term{t}_1 = \text{nat}.$

同上.
\end{case}
\end{proof}

\begin{annotation}
\rm 换言之progress保证是任意一个well-typed term，它可能是一个value或者可以进一步根据evaluation rules推导. 
\end{annotation}


\begin{theorem}
\rm \redt{preservation} If a well-typed term takes a step of  evaluation, then the resulting term is also well typed. 
\end{theorem}

\begin{proof}
\rm 和证明progress类似，对于每个case需要分析其所有的one step, 然后根据typing rules，证明type perservation. i.e. representative case.
\begin{case}
$\term{t} = \ifelse{\term{t}_1}{\term{t}_2}{\term{t}_3} ~~~~ \text{hyp}:~ \term{t}_1 = \text{bool} ~~ \term{t}_2 = \text{T} ~~ \term{t}_3 = \text{T}$. 

当$\term{t}_1 = \true$或者$\term{t}_1 = \false$时，我们对$\term{t}$一步evaluation得到$t' = \term{t}_2$或者$t' = \term{t}_3$，显然$t'$ with $T$.  另外当我们take $\term{t}_1 \to \term{t}_1'$时，我们也可以得到$\term{t}' = \ifelse{\term{t}_1'}{\term{t}_2}{\term{t}_3}$，此时依然有$\term{t}'$ with $T$.  
\end{case}

\end{proof}

\begin{definition}
\rm
$$
\text{safty} = \text{progress} + \text{preservation}.
$$
\end{definition}


\newpage
\subsection{Simply Typed Lambda-Calculus}

\begin{definition}
\rm Define the type of $\lambda$-abstraction(function) as follow
$$
\termtype{\lam{\term{x}}{\term{t}}}{\singletype{T}_1 \to \singletype{T}_2}
$$
it classifies function that expect agrument of type $\singletype{T}_1$ and return result of type $\singletype{T}_2$. The type constructor $\to$ is right-associative. 
\end{definition}


\begin{annotation}
\rm 试想我们应该怎样给一个function赋予一个type呢？ 首先要解决是这个function需要的argument的type是怎样的？ 这里自然地会想到两种方法，一是直接给argument打上annotation，而是从function body推出argument的type. 第一种type annotation通常称为explicitly typed, 第二种则称其为implicitly typed. 我们如果采用第一种方法，假设给定$\termtype{\term{x}}{\singletype{T}_1}$，同时将$\term{t}_2$中的所有出现的$\term{x}$的type都表示为$\singletype{T}_1$得到$\termtype{\term{x}}{\singletype{T}_2}$，那么显然此时就可以构造出一个abstraction和它对应type为$\termtype{\lam{\term{x}}{\term{t}_2}}{\singletype{T}_1 \to \singletype{T}_2}$，形式化的描述这个type rule即为
$$
\infer{\termtype{\lam{\term{x}}{\term{t}_2}}{\singletype{T}_1 \to \singletype{T}_2}}{\termtype{\term{x}}{\singletype{T}_1} \vdash \termtype{\term{t}_2}{\singletype{T}_2}}
$$
其中$\vdash$可以解释为under，即obtain some type relations under some assumptions. 特别地$\vdash \termtype{\term{x}}{\singletype{T}}$表示assumptions是空的. 
\end{annotation}

\begin{definition}
\rm A typing context $\Gamma$ is a sequence of distinct variables and thier types as follow
$$
\Gamma = \termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\termtype{\term{x}_3}{\singletype{T}_3},\cdots
$$
\end{definition}

\begin{annotation}
\rm \redt{rule of typing abstractions} 如果考虑上nested abstraction的情况，我们扩展一下前面提到的type inference
$$
\infer{\Gamma \vdash \termtype{\lam{\term{x}}{\term{t}_2}}{\singletype{T}_1 \to \singletype{T}_2}}{\termtype{\Gamma,\term{x}}{\singletype{T}_1} \vdash \termtype{\term{t}_2}{\singletype{T}_2}}.
$$
这里我们规定$\term{t}_2$中除$\term{x}$外的free variables均在$\Gamma$中.
\end{annotation}

\begin{annotation}
\rm \redt{rule of variables} A variable has whatever type we are currently assuming it to have,
$$
\infer{\Gamma \vdash \termtype{\term{x}}{\singletype{T}}}{\termtype{\term{x}}{\singletype{T}} \in \Gamma}
$$
\end{annotation}


\begin{annotation}
\rm \redt{rule of applications}
$$
\infer{\Gamma \vdash \termtype{\term{t}_1 \term{t}_2}{\singletype{T}_2}}{\Gamma	\vdash \termtype{\term{t}_1}{\singletype{T}_1 \to \singletype{T}_2 } & \Gamma \vdash \termtype{\term{t}_2}{\singletype{T}_2} }
$$
\end{annotation}

\begin{annotation}
\rm \redt{rule of conditionals}  
$$
\infer{\Gamma \vdash \termtype{\ifelse{\term{t}_1}{\term{t}_2}{\term{t}_3}}{\singletype{T}}}{\Gamma \vdash \termtype{\term{t}_1}{\singletype{bool}} & \Gamma \vdash \termtype{\term{t}_2}{\singletype{T}} & \Gamma \vdash \termtype{\term{t}_3}{\singletype{T}}}
$$
\end{annotation}


\begin{annotation}
\rm We often use $\lambda_{\to}$ to refer to the simply typed lambda-calculus. 
\end{annotation}

\begin{theorem}
\rm \redt{uniquness of types} In a given typing context $\Gamma$, a term $\term{t}$ has at most one type. That is, if a term is typable, then it's type is unique. 
\end{theorem}

\begin{lemma}
\rm \redt{canonical forms}
\begin{enumerate}
	\item If $\term{v}$ is a value of type $\singletype{bool}$, then $\term{v}$ is either $\term{true}$ or $\term{false}$;
	\item If $\term{v}$ is a value of type $\singletype{T}_1\to\singletype{T}_2$, then $\term{v} = \lam{\termtype{\term{x}}{\singletype{T}_1}}{\term{t}_2}$.
\end{enumerate}
\end{lemma}

\begin{lemma}
\rm \redt{weakening} If $\Gamma \vdash \termtype{\term{t}}{\singletype{T}}$ and $x \notin \text{dom}(\Gamma)$, then $\Gamma, \termtype{\term{x}}{\singletype{S}} \vdash \termtype{\term{t}}{\singletype{T}}$.
\end{lemma}

\begin{theorem}
\rm \redt{progress} Suppose $\term{t}$ is a closed, well-typed term(that is $\vdash \termtype{\term{t}}{\singletype{T}}$). Then either $\term{t}$ is a value or else there is some $\term{t}'$ with $\term{t} \to \term{t}'$. 
\end{theorem}

\begin{proof}
proved by structural induction.
\end{proof}

\begin{theorem}
\rm \redt{preservation under substitution} If $\Gamma,  \termtype{\term{x}}{\singletype{S}} \vdash \termtype{\term{t}}{\singletype{T}}$ and $\Gamma \to \termtype{\term{s}}{\singletype{S}}$, then $\Gamma \vdash \termtype{[\term{x} \to \term{s}]\term{t}}{\singletype{T}}$.
\end{theorem}

\begin{proof}
\rm 写几步structural induction找找感觉，因为substitution是第一次出现. 这里我们依然对$\term{t}$来进行归纳.  

\begin{case}
若$\term{t} = \term{v}$，其中$\term{v}$为一个variable. 

分两种情况: (1 若$\term{v} = \term{x}$，则$[\term{x} \to \term{s}]\term{t} = [\term{x} \to \term{s}]\term{v} = \term{s}$，而根据命题条件$\Gamma \to \termtype{\term{s}}{\singletype{S}}$，显然成立. (2 其他情况下，则有$[\term{x} \to \term{s}]\term{v} = \term{v}$，即这个substitution没起作用，显然还是成立. 
\end{case}
\end{proof}

\begin{annotation}
\rm 对于一个language有两种特别的刻画形式：
\begin{itemize}
	\item \redt{Curry-style} 首先我们定义terms，再定义关于它们的求值规则(evaluation rules)，来确定terms的语义. 然后我们在定义一个类型系统来拒绝一些不符合我们预期的terms. 因此语义刻画是在类型之前，即它是一种implicit typing, 也可以看做一种ploymorphism. 例如对于identity abstraction, 在curry-style下可以使用一种type variables，它可以代指所有可能的type， 
	$$
	I = \lam{x}{x} : \sigma \to \sigma
	$$ 
	\item \redt{Church-style} 首先我们定义terms，再确定一些well-typed的terms. 然后只给well-typed terms制定求值规则，来确定其语义. 因此类型先于语义，即它是一种explicit typing. 例如对于identity abstraction, 对每一种可能type，在church-style下我们都可以得到family of identity,
	$$
	I_A = \lam{x:A}{x} : A \to A.
	$$
\end{itemize}
它们两个最大的不同就是我们在谈论一个term的语义的时候到底是否关系它此时是well-typed. Curry-style通常适用于刻画implicitly typed system，而Church-style通常用于刻画explicitly typed system. 
\end{annotation}


\newpage
\section{Type Extensions}

\subsection{Known Types}

\begin{definition}
\rm \redt{base type} Something like bool, nat, float and string, these type are for describing simple and unstructured values and approriate primitive operation for manipulating these values.
\end{definition}

\begin{definition}
\rm \redt{unit type} a constant $\term{unit}$ with unique type $\singletype{Unit}$, the type can be only from this constant. we often use $*$ for the unique unit term and $1$ for the unit type
$$
\infer[]{\Gamma \vdash *:1}{}
$$
\end{definition}

\begin{definition}
\rm The \redt{sequencing} notation $\seq{\term{t}_1}{\term{t}_2}$ has the effect of evaluating $\term{t}_1$，throwing away its trivial result($\term{unit}$), and going on to evaluate $\term{t}_2$. 
\end{definition}

\begin{annotation}
\rm \redt{ first way to formalize sequencing} Add $\seq{\term{t}_1}{\term{t}_2}$ as a new alternative in the syntax of terms, and then add two evaluation rules
$$
\begin{array}{cc}
\infer{\seq{\term{t}_1}{\term{t}_2} \to \seq{\term{t}_1'}{\term{t}_2}}{\term{t}_1 \to \term{t}_1'} \\
\seq{\term{unit}}{\term{t}_2} \to \term{t}_2 
\end{array}
$$
and a typing rule
$$
\infer{\Gamma \vdash \termtype{\seq{\term{t}_1}{\term{t}_2}}{\singletype{T}_2}}{\Gamma \vdash \termtype{\term{t}_1}{\singletype{Unit}} & \Gamma \vdash \termtype{\term{t}_2}{\singletype{T}_2}}
$$
\end{annotation}

\begin{annotation}
\rm \redt{ second way to formalize sequencing} Regard $\seq{\term{t}_1}{\term{t}_2}$ as an abbreviation for the term $(\lam{\termtype{\term{x}}{\singletype{Unit}}}{\term{t}_2})~\term{t}_1$, where $\term{x} \in \text{FV}(\term{t_2})$. 
\end{annotation}

\begin{theorem}
\rm Suppose $\lambda^E$ for the simply typed lambda-calcuclus with the first way of sequencing formalization and $\lambda^I$ for the simply typed lambda-calculus with $\singletype{Unit}$. Let $\func{e}{\lambda^E}{\lambda^I}$ be the elaboration function that translates from the $\lambda^E$ to $\lambda^I$ by replacing every occurrence of $\seq{\term{t}_1}{\term{t}_2}$ with $(\lam{\termtype{\term{x}}{\singletype{Unit}}}{\term{t}_2})~\term{t}_1$, where $\term{x} \in \text{FV}(\term{t_2})$. Then for each $\term{t}$ of $\lambda^E$, we have 
\begin{enumerate}
	\item $\term{t} \to_E \term{t}'$ iff $e(\term{t}) \to _I e(\term{t}')$;
	\item $\Gamma \vdash_E \termtype{\term{t}}{\singletype{T}}$ iff $\Gamma \vdash_I \termtype{e(\term{t})}{\singletype{T}}$. 
\end{enumerate} 
\end{theorem}

\begin{annotation}
\rm 这个sequencing目前来说和我们现代下的语言里面对应的概念还是有差别的. 根据第一个formalization，也就是我们定义里面提到的它是依赖$\term{t}_1$的evaluation result, 我们对一个sequencing能做的就是首先对$\term{t}_1$进行evaluating，只有它的result是一个$\singletype{Uint}$的时候，我们可以尝试丢掉它转而去处理$\term{t}_2$.  显然当$\term{t}_1$不是trivial的时候，$\term{t_2}$永远得不到的evaluating，就停在了某个$\seq{\term{t}_1'}{\term{t}_2}$. 这是就目前而言的我们可以做的事情. 

再关于第二个formalization而言，它是一个很特别的带注解的application，会有一个自然地疑问，如果此时$\term{t}_1$的evaluation result不是$\singletype{Unit}$，怎么让这个application make sense? 是卡在这里，还是怎样？ 显然在前述的corresponding theorem下我更倾向于是卡在这里.
\end{annotation}

\newpage
\subsection{Known Features}

\begin{definition}
\rm \redt{Ascription} is simple feature for ascribe a particular type to a given term. We write "$\term{t}~\text{as}~\singletype{T}$" for the "the term $\term{t}$, to which we ascribe the type $\singletype{T}$".  
\end{definition}

\begin{definition}
\rm \redt{Let Bindings} $\term{let}~ \term{x}=\term{t}_1~\term{in}~\text{t}_2$, 它们的evaluation rule和type rule根lambda abstraction是差不多的，即
$$
\term{let}~ \term{x}=\term{t}_1~\term{in}~\text{t}_2 = (\lam{\termtype{x}{\singletype{T}_1}}{\term{t}_2})~\term{t}_1. 
$$
\end{definition}


\begin{definition}
\rm \redt{Pair} Pairing, written $\term{t}=\left<\term{t}_1,\term{t}_2\right>$ and projection, written $\projone{\term{t}}$ for the $\term{t}_1$ and $\projtwo{\term{t}}$ for the $\term{t}_2$. One new type constructor, $\singletype{T}_1 \times \singletype{T}_2$, called the product of $\singletype{T}_1$ and $\singletype{T}_2$.
\end{definition}

\begin{definition}
\rm \redt{Tuple} is general formalization of Pair.
\end{definition}

\begin{definition}
\rm \redt{Record} Recording, written $\{\term{l}_1 =\term{t}_1, \cdots, \term{l}_n =\term{t}_n\}$ and thier type $\{\termtype{\term{l}_1}{\singletype{T}_1}, \cdots, \termtype{\term{l}_1}{\singletype{T}_1}\}$. 
\end{definition}

\begin{definition}
\rm \redt{pattern matching} Given two kinds of patterns, varible pattern $\term{x}$ and record pattern $\{\term{l}_1 =\term{p}_1, \cdots, \term{l}_n =\term{p}_n\}$(so it can be nested). Plus a match function $\func{match}{P \times V}{\text{Subs} \cup \text{Fail}}$, where $P$ are patterns, $V$ is values, $\text{Subs}$ are substitutions and $\text{Fail}$ means matching fails. The matching rules as follow
$$
\begin{array}{cc}
match(\term{x}, \term{v}) = [\term{x} \to \term{v}] & M-Var \\
\infer{match(\{\term{l}_1 =\term{p}_1, \cdots, \term{l}_n =\term{p}_n\}, \{\term{l}_1 =\term{v}_1, \cdots, \term{l}_n =\term{v}_n\}) = \sigma_1 \circ \cdots \circ \sigma_n}{\text{for each}~i~match(\term{p}_i,\term{v}_i)= \sigma_i}& M-Rcd
\end{array}
$$
The computation rule for pattern matching generalizes the let-binding as follow
$$
\term{let}~ \term{p}=\term{v}~\term{in}~\text{t} = match(\term{p},\term{v})~\term{t}_1. 
$$
\end{definition}

\begin{definition}
\rm A \redt{sum type} is written as $\singletype{T}_1 + \singletype{T}_2$, there are two terms can be desribed this type: 
\begin{enumerate}
	\item Assume $\termtype{\term{t}_1}{\singletype{T}_1}$, then $\termtype{\redt{\inl{\term{t}_1}}}{\singletype{T}_1 + \singletype{T}_2}$;
	\item Assume $\termtype{\term{t}_2}{\singletype{T}_2}$, then $\termtype{\redt{\inr{\term{t}_2}}}{\singletype{T}_1 + \singletype{T}_2}$.
\end{enumerate}
There is a $\term{case}$ construct that allows us to distinguish whether a given value comes from the left or right branch of a sum,
$$
\infer{\caseof{\term{t}_0}{\term{t}_1:\singletype{T}}{\term{t}_2:\singletype{T}}}{\Gamma \vdash \term{t}_0:\singletype{T}_1 + \singletype{T}_2 & \Gamma,x_1:\singletype{T}_1 \vdash \term{t}_1:\singletype{T} & \Gamma,x_2:\singletype{T}_2 \vdash \term{t}_2:\singletype{T}}
$$
where $x_1 \mapsto \term{t}_1:\singletype{T}$ means $[x_1 \to \singletype{T}_1]\term{t}_1$, another one is similar. 
\end{definition}

\begin{annotation}
\rm 上述case分几步理解
\begin{enumerate}
	\item 首先得有一个$\term{t}_0:\singletype{T}_1 + \singletype{T}_2$, 
	\item 然后我们有两个type相同的terms $\term{t}_1:\singletype{T}$和$\term{t}_2:\singletype{T}$，它们分别各自都有一个bounded variables $x_1::\singletype{T}_1$和$x_1::\singletype{T}_1$, 因此这里实际上一个隐含的abstraction，最后
	\item 我们确定$t_0$是$\text{inl} x$和$\text{inr} y$, 根据其选择$\term{t}_1$和$\term{t}_2$ apply上对应的$x$和$y$，这里我们使用$x$和$y$目的是将其和两个bounded variables区分开来.
\end{enumerate}
\end{annotation}


\begin{annotation}
\rm 这里存在一个\bluet{类型唯一性}的问题，如果$\termtype{\term{t}_1}{\singletype{T}_1}$，那么对于任意$\singletype{T}_2$，都有$\termtype{\inl{\term{t}_1}}{\singletype{T}_1 + \singletype{T}_2}$, 显然$\inl{\term{t}_1}$的类型就不唯一了. 

这里有三种解决办法
\begin{enumerate}
	\item 留着$\singletype{T}_2$符号化，typechecker继续往后推，如果遇到某个地方$\singletype{T}_2$可能在当前context需要成为某个特定的值;
	\item 给所有可能的$\singletype{T}_2$一个unified representation(ocaml);
	\item 在语法上要求显式地给$\singletype{T}_2$一个type annotation. 
\end{enumerate}
\end{annotation}

\begin{definition}
\rm \redt{variant} is generalization of sum $\left<\term{l}_1:\term{T}_1, \term{l}_2:\term{T}_2\right>$. 
\end{definition}

\begin{definition}
\rm \redt{option} $\left<\term{none}:\term{Unit}, \term{some}:\term{Nat} \right>$. 
\end{definition}

\begin{definition}
\rm \redt{enumeration} An enumerated type (or enumeration) is a variant type in which the field type associated with each label is $\term{Unit}$.
\end{definition}

\begin{definition}
\rm \redt{single-field variant} $\left<\term{l}:\term{T} \right>$.
\end{definition}

\begin{annotation}
\rm single-field variant的主要作用由一个type构造出多个不一样的types但是仅仅是用附加的labels来刻画的，这就可以描述具有相同type但是不同对象.
\end{annotation}

\begin{definition}
\rm \redt{void type} An emptyset of term with unique type void\footnote{There is no term for void type}, we often use $0$ for the unique void type. When we reach a void type, we have reached an error, and thus we can throw any typed exception. 
$$
\infer[]{\vdash \text{abort}_A~t_1:A}{t_1:0}
$$  
\end{definition}

\begin{annotation}
\rm The abort rule extracts a term of any type from the void type. 
\end{annotation}

\newpage
\subsection{Normalization}

\begin{theorem}
\rm If $\vdash \term{t}:\singletype{T}$, then $\term{t} \to^* \term{v}$, where $\term{v}$ is a value, or abbreviate $\term{t}\Downarrow$. 
\end{theorem}

\begin{remark}
\rm 上述normalization theorem使用是simply typed lambda calculus. 
\end{remark}

\begin{annotation}
\rm Normalization又名termination，它在描述一个well-typed的term通过evaluation最终可以变成一个value. 这里values包括false，true和lambda abstraction. 自然地，这里考虑使用induction hypothesis来证明，但是处理不了application。对于application我们需要使用reduction rule
$$
\infer{\Gamma \vdash \termtype{\term{t}_1 \term{t}_2}{\singletype{T}_2}}{\Gamma	\vdash \termtype{\term{t}_1}{\singletype{T}_1 \to \singletype{T}_2 } & \Gamma \vdash \termtype{\term{t}_2}{\singletype{T}_2} }
$$
根据假设$\term{t}_1, \term{t}_2$都是normalizable，那么设$\term{t}_1 \to^* \term{t}_1' = \lam{\termtype{x}{\singletype{T}_1}}{\term{t}_3}$(这里用了一下value of function type的canonical form)和$\term{t}_2 \to^* \term{t}_2'$，其中$\term{t}_2'$是normalized. 再来一个$\beta$ reduction，则有
$$
\term{t}_1' \term{t}_2' = [x \to \term{t}_2']\term{t}_3'
$$
这里有两个问题: (1)$\term{t}_3$是一个怎样的形式？(2) substitution干了什么？  
\end{annotation}


\begin{definition}\label{logical predicate of SN}
\rm Suppose the logical predicate for strong normalization as follow
$$
\begin{array}{ll}
\text{SN}_{\singletype{A}}(\term{t}) \iff \vdash \termtype{\term{t}}{\singletype{A}} ~\wedge~ \term{t}\Downarrow,\\
\text{SN}_{\singletype{T}_1 \to \singletype{T}_2}(\term{t}) \iff \vdash \termtype{\term{t}}{\singletype{T}_1 \to \singletype{T}_2} ~\wedge~ \term{t}\Downarrow \wedge ~\forall \term{t_1}.~\text{SN}_{\singletype{T}_1}(\term{t}_1) \Rightarrow \text{SN}_{\singletype{T}_2}(\term{t}~\term{t}_1)
\end{array} 
$$
where $\singletype{A}$ is base type. 
\end{definition}

\begin{annotation}
\rm 观察上述definition是加强了application的conclude(?)，可以通过这两个logical predicate来继续我们的证明，接下来的证明分两步走:
\begin{enumerate}
	\item 首先证明$\vdash \termtype{\term{t}}{\singletype{T}} \Rightarrow \text{SN}_\singletype{T}(\term{t})$，即所有closed well-typed的term都复合上述定义的logical predicate,
	\item 然后$\text{SN}_\singletype{T}(\term{t}) \Rightarrow \term{t}\Downarrow$.
\end{enumerate}
这种手法就是所谓\redt{logical relation}证明方法. 
\end{annotation}

\begin{lemma}\label{logical predicate well-defined}
\rm $\text{SN}_\singletype{T}(\term{t}) \Rightarrow \term{t}\Downarrow$
\end{lemma}

\begin{proof}
根据定义这是显然的. 
\end{proof}

\begin{annotation}
\rm 证明过程的第一步又会拆成两步:
\begin{enumerate}
	\item $\text{SN}_\singletype{T}(\term{t})$将会在$\term{t}$的evalution过程中保持,
	\item 再做根据type derivations的induction，但是于证明abstraction $\term{t}=\lam{\termtype{x}{\singletype{T}_1}}{\term{t}_2}$满足$\text{SN}_{\singletype{T}_1 \to \singletype{T}_2}(\term{t})$的时候，注意这里我们$\text{SN}$对closed term而言的，因此我们这里根据derivation是
	$$
	\infer{\vdash \lam{\termtype{x}{\singletype{T}_1}}{\term{t}_2}}{\termtype{\term{x}}{\singletype{T}_1} \vdash \termtype{\term{t}_2}{\singletype{T}_2}}
	$$
	问题来了这个inference rule的premise不是empty，因此我们没法继续用induction hypothesis来继续我们的证明，这里需要做一个推广(generalization)，即$\Gamma	\vdash \termtype{\term{t}}{\singletype{T}} \Rightarrow \text{SN}_\singletype{T}(\term{t})$.  这里又会出现一个问题是的$\term{t}$可能不是closed了，因此我们考虑将这个open term $\term{t}$实例化，即从$\Gamma$出发构造substitution给$\term{t}$，让它重新变成closed. 最终我们所需要的结论只是generalization的一个推论.
\end{enumerate}
\end{annotation}

\begin{lemma}\label{logical predicate preserved under evalutaion}
\rm If $\termtype{\term{t}}{\singletype{T}}$ and $\term{t} \to \term{t}'$, then $\text{SN}_{\singletype{T}}(\term{t}) \iff \text{SN}_{\singletype{T}}(\term{t}')$ 
\end{lemma}

\begin{proof}
首先由$\term{t} \to \term{t}'$，那么有$\term{t}\Downarrow \iff \term{t}'\Downarrow$. 再分情况，若$\singletype{T} = \singletype{A}$，证明就结束了; 若$\singletype{T} = \singletype{T}_1 \to \singletype{T}_2$，由$\term{t}~\term{t}_1 \to \term{t'}~\term{t}_1 $，则$\term{t}~\term{t}_1\Downarrow \iff \term{t}'~\term{t}_1\Downarrow$，又回到第一种情况，证明了function type额外需要的条件. 
\end{proof}

\begin{lemma}\label{logical predicate under substitution}
\rm If $\termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\cdots,\termtype{\term{x}_n}{\singletype{T}_n} \vdash \termtype{\term{t}}{\singletype{T}}$ and $\term{v}_1,\term{v}_1,\cdots,\term{v}_1$ are closed values of $\singletype{T}_1,\singletype{T}_2,\cdots,\singletype{T}_n$ with $\text{SN}_{\singletype{T}_i}(\term{v}_i)$, then $\text{SN}_{\singletype{T}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t})$
\end{lemma}

\begin{proof}
\rm structural induction as follow
\begin{case}
$$
\begin{array}{ll}
\term{t} = \term{x}_i \\
\singletype{T} = \singletype{T}_i
\end{array}
$$ 

显然成立.
\end{case}

\begin{case}
$$
\begin{array}{ll}
\term{t} = \lam{\termtype{\term{x}}{\singletype{S}_1}}{\term{s}_2} \\
\singletype{T}=\singletype{S}_1 \to \singletype{S}_2 \\
\termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\cdots,\termtype{\term{x}_n}{\singletype{T}_n},\termtype{\term{x}}{\singletype{S}_1} \vdash \termtype{\term{s}_2}{\singletype{S}_2}
\end{array}
$$

显然此时$[\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}$已经一个value了，因为$\term{t}$本来就是一个abstraction.	此时需要额外证明applying过程，即给定任意的$\text{SN}_{\singletype{S}_1}(\term{s})$，有$\text{SN}_{\singletype{S}_2}(([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t})~\term{s})$. 根据Lemma\ref{logical predicate well-defined}，我们有$\term{s} \to^* \term{v}$，根据归纳假设即有
$$
\text{SN}_{\singletype{S}_2}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n,\term{x} \to \term{v} ]\term{t})
$$
而
$$
([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t})~\term{s} \to^* [\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n,\term{x} \to \term{v} ]\term{t},
$$
再用一下Lemma\ref{logical predicate preserved under evalutaion}, 即可得到我们想要的. 
\end{case}

\begin{case}
$$
\begin{array}{ll}
\term{t} = \term{t}_1\term{t}_2 \\
\termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\cdots,\termtype{\term{x}_n}{\singletype{T}_n} \vdash \termtype{\term{t}_1}{\singletype{T}_{11} \to \singletype{T}_{12}} \\
\termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\cdots,\termtype{\term{x}_n}{\singletype{T}_n} \vdash \termtype{\term{t}_2}{\singletype{T}_{11}} \\
\singletype{T} = \singletype{T}_{12}
\end{array}
$$

根据归纳假设有$\text{SN}_{\singletype{T}_{11} \to \singletype{T}_{12}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_1)$和$\text{SN}_{\singletype{T}_{11}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_2)$. 再根据$\text{SN}_{\singletype{T}_{11} \to \singletype{T}_{12}}$的definition，有
$$
\begin{array}{ll}
\text{SN}_{\singletype{T}_{12}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_1 [\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_2) \\
= \text{SN}_{\singletype{T}_{12}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_1~\term{t}_2) 
\end{array}
$$
得证.
\end{case}
\end{proof}

\begin{annotation}
\rm Lemma\ref{logical predicate under substitution}中substitution可以记为$\gamma = [\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]$，也可以直接记为$\gamma \models \Gamma$，理解为"the substitution $\gamma$ statisfies the type environment, $\Gamma$". 
\end{annotation}

\begin{corollary}
\rm $\vdash \termtype{\term{t}}{\singletype{T}} \Rightarrow \text{SN}_\singletype{T}(\term{t})$.
\end{corollary}

\begin{proof}
\rm 直接从Lemma\ref{logical predicate under substitution}可得.
\end{proof}

\newpage
\subsection{References}

\begin{definition}
\rm  A \redt{reference value} represents mutable cell. The basic operations on reference are allocation, dereferencing and assignment. 

To allocate a reference, we use the $\term{ref}$ operator, providing an initial value for the new cell
$$
\term{r} = \text{ref}~5 \Rightarrow \termtype{\term{r}}{\singletype{Ref}~\singletype{Nat}}. 
$$

To read a current value of this cell, we use the derefencing operator $!$
$$
!\term{r} \Rightarrow \termtype{5}{\singletype{Nat}}. 
$$ 


To change the value stored in the cell, we use the assignment operator
$$
\assign{\term{r}}{7} \Rightarrow \termtype{\term{unit}}{\singletype{Unit}}. 
$$
The result of the assignment is the trivial $\term{unit}$ value. 
\end{definition}

\begin{definition}
\rm The  references $\term{r}$ and $\term{s}$ are said to be aliases for the same cell. 
\end{definition}

\begin{annotation}
\rm 在这里就正式的引入了sequencing带来的side effort，关于references的evaluation rule非常冗余，这里简单记关键几点
\begin{enumerate}
	\item references会被抽象成location indexs $l \in \mathcal{L}$. states会被抽象成store function $\mathcal{L} \to \text{values}$;
	\item 之前的所有evaluation都会附近上额外store function;
	\item dereference一个不存在的location，会给出一个错误. dereference operator要等到它右边的term被evaluated成一个value才能起作用，同理allocation也一样;
	\item 对于assignment，需要先evaluate左边term. 
\end{enumerate}
\end{annotation}

\begin{definition}
\rm A \redt{store typing} is a finite function mapping locations to types, we use the metavariable $\Sigma$ to range over such functions. the typing rule for locations can be formalized as follow
$$
\infer{\Gamma | \Sigma \vdash \termtype{l}{\singletype{Ref}~\singletype{T}}}{\Sigma({l})=\singletype{T}_1}
$$
\end{definition}

\begin{annotation}
\rm 这里为什么要构造一个这样的function呢？ 因为自然地考虑$l$应该依赖于store function $\mu$，这里对应的typing rule为
$$
\infer{\Gamma | \mu \vdash \termtype{l}{\singletype{Ref}~\singletype{T}}}{\Gamma | \mu \vdash \termtype{\mu({l})}{\singletype{T}_1}}
$$
如果$\mu$的结构是这样
$$
(l_1 \to \lam{\termtype{x}{\singletype{Nat}}}{!l_2~\term{x}},
~l_2 \to \lam{\termtype{x}{\singletype{Nat}}}{!l_1~\term{x}})
$$
这里cyclic reduction的过程,$l_1$的type依赖$l_2$的type依赖，反过来$l_2$的type依赖$l_1$的type. 那么如何构造这样一个$\Sigma\colon\mathcal{L} \to T$的map呢？ 它是可以在evaluation过程动态构造的，因为只要一个location第一次被allocated，那么在它对应的位置上一定有一个具体的type，同样无论后面经历assignment多少次都只有唯一的type对应，这样我们可以一开始就将$\Sigma$置为一个empty map，再根据对应的操作是维护它就可以了. 
\end{annotation}

\begin{definition}
\rm \redt{(Connection between $\mu$ and $\Sigma$)} A store $\mu$ is said to be well typed with respest to a typing context $\Gamma$ and a store typing $\Sigma$, written $\Gamma \mid \Sigma \vdash \mu$, if $\text{dom}(\mu) = \text{dom}(\mu)$ and $\Gamma \mid \Sigma \vdash \termtype{\mu({l})}{\Sigma(l)}$ for every $l \in \text{dom}(\mu)$. 
\end{definition}

\begin{theorem}
\rm \redt{Preservation} If 
$$
\begin{array}{lll}
\Gamma \mid \Sigma \vdash \termtype{\term{t}}{\singletype{T}} \\
\Gamma \mid \Sigma \vdash \mu  \\
\term{t} \mid \mu \to \term{t}' \mid \mu' 
\end{array}
$$
then, for some $\Sigma' \supseteq \Sigma$,
$$
\begin{array}{ll}
\Gamma \mid \Sigma' \vdash \termtype{\term{t}'}{\singletype{T}} \\
\Gamma \mid \Sigma' \vdash \mu'
\end{array}
$$
\end{theorem}

\begin{annotation}
\rm 其中$\Sigma' \supseteq \Sigma$产生的原因是allocation operator会带来新的location，同时不用考虑assignment operator，因为sequencing没有在当前的语法中，它的side effort也无法起作用，所以一个包含关系就够了. 
\end{annotation}


\begin{theorem}
\rm \redt{Progress} Suppose $\term{t}$ is closed, well-typed term, that is $\cdot \mid \Sigma \vdash \termtype{\term{t}}{\singletype{T}}$ for some $\singletype{T}$ and $\Sigma$. Then either $\term{t}$ is a value or else, for any store $\mu$ such that $\cdot \mid \Sigma \vdash \mu$, there is some term $\term{t}'$ and store $\mu'$ with $\term{t} \mid \mu \to \term{t}' \mid \mu'$.
\end{theorem}

\newpage
\subsection{Recursion}

\begin{definition}
\rm There are two basic approaches to recursive types.
\begin{enumerate}
	\item \redt{equi-resursive} approach: given two types expression as definition-ally equal-interchangeable in all contexts. 
	\item \redt{iso-resurisive} approach: takes a recursive type and its unfolding  as diffrent, but isomorphic. 
\end{enumerate}
\end{definition}

\begin{definition}
\rm An explicit \redt{recursion operator} $\mu$ for types:
$$
\mu \alpha. \tau 
$$
it has two interepretion from above tow approaches.
\begin{enumerate}
	\item equi-resursive: A recursive type $\mu \alpha. \tau$ is the infinite type satifying the equation $\alpha = \tau$.
	\item iso-resursive: A recursive type $\mu \alpha. \tau$ was regarded as an infinite type and consider equal to its unfolding $[\alpha \to \mu \alpha. \tau ]\tau$. 
\end{enumerate}
\end{definition}

\begin{annotation}
\rm equi-recursive性质可以告诉typechecker对应的recursion type它可以适当的转换，例如我们可以recursion type $T$满足等式$X = X \to X$, 给定两个type均为$T$的terms $M,N$，当考虑application时$M N$， typechecker就知道$M: T \to T$和$N: T$. 

而iso-resursive性质就是将equi-recurisve里面隐式的转换用unfolding和unfold变成显式的了. 这里有一个小小问题探讨，以上的所有recursion的描述都是针对type而言的，不是之前在untyped $\lambda$-calculus里面针对term而言的.  
但是unfold和fold会作为primilitives出现在terms里面，那么这里需要对它们有一个准确的描述. 

首先每个recursive typeun都有unfold和fold，因此它们形式化的定义如下
$$
\begin{aligned}
\text{unfold}[\mu \alpha.\tau]: \mu \alpha.\tau \to [\alpha \to \mu \alpha.\tau]\tau \\
\text{fold}[\mu \alpha.\tau]: [\alpha \to \mu \alpha.\tau]\tau \to \mu \alpha.\tau
\end{aligned}
$$
例如某个term具有unfolded formation，对其进行fold可以写作$\text{fold}[\mu \alpha.\tau]~t$. 那么它们的isomorphism体现在
$$
\text{fold}[\mu \alpha.\tau] (\text{unfold}[\mu \alpha.\tau]~t) = t
$$
\end{annotation}

\begin{example}
\rm The type natural list are defined as follow
$$
NatList = \mu \alpha. \left<\text{nil}:Unit,~\text{cons}:\{Nat,\alpha\} \right>. 
$$
\end{example}

\begin{definition}
\rm A fixed constructor for function type $\tau$ is defined as follow
$$
\text{fix}_\tau = \lam{f:\tau \to \tau}{(\lam{x:(\mu \alpha.\alpha\to \tau)}{f~(x~x)})~~(\lam{x:(\mu \alpha.\alpha\to \tau)}{f~(x~x)})}.
$$
\end{definition}


\begin{annotation}
\rm 去掉$\text{fix}_\tau$中所有的type annotation，就可以得到在untyped lambda calculus里面的fix constructor. 这里$x$必须是一个arrow type，同时它的domain也是$x$它自己，显然我们找不到这样finite type，recurison operator在这里就神奇的起作用了. 
\end{annotation}

\begin{definition}
\rm A well-typed term whose evalutaion will diverge.
$$
\text{diverge}_\tau = \lam{:Unit}{\text{fix}_\tau~\text{id}}
$$
\end{definition}

\begin{annotation}
\rm 这意味recursive type的引入将会破坏strong normalization. 
\end{annotation}

\begin{example}
\rm 利用recursive type可以完美地将untyped lambda calculus $\Lambda$(only include variables, abstraction and application)变成typed. 给每个在$\Lambda$里面的term都assign上一个recursive type $D$
$$
D = \mu \alpha. \alpha \to \alpha. 
$$
因为arrow type的天然存在，会导致出现$D \to D$，因此我们需要一个unifier. 其中abstraction对应了fold操作，我们需要将$D \to D$变成$D$保持一致, 即
$$
\text{lam} = \lam{f:D \to D}{f~\text{as}~D},
$$
而application对应unfold操作，我们需要将第一个term从$D$变成$D \to D$, 这样才能apply，即
$$
\text{ap} = \lam{f:D}{\lam{x:D}{f~a}}.
$$
给定closed term $M \in \Lambda$，用$M^*$表示$M$对应的typed term，两者对应如下
$$
\begin{aligned}
&x^* = x \\
&(\lam{x}{M})^* = \text{lam}~(\lam{x:D}{M^*}) \\
&(M N)^* = \text{ap}~ M^* N^*
\end{aligned}
$$
\end{example}

\newpage
\section{Subtyping}

\subsection{STLC}
\begin{annotation}
\rm \redt{Motivation} 考虑下面application
$$
(\lam{\termtype{r}{\{x:Nat\}}}{r.x})~\{x=0,y=1\},
$$
它在前面的STLC里面不是typable的，显然argument不满足abstraction里面的explicit annotation，我们希望兼容这种问题. 
\end{annotation}

\begin{definition}
\rm Let $S,T$ be any terms, $S$ is a \redt{subtype} of $T$ if any term of type $S$ can safely be used in a context where a term of type $T$ is expected, simply written $\subtyp{S}{T}$. 
\end{definition}

\begin{annotation}
\rm 首先举个例子$\subtyp{\{x:\tau_1, y:\tau_2\} }{\{x:\tau_1\}}$，
你如果直接思考两个record的势来比较显然是不符合直接的，但是这个你得用cast的想法来理解，这就相当于$S$的类型蕴含着$T$的类型，这个理解在逻辑上其实比较好理解，$S$里面的limits实际上要比$T$多，因此"the element of $S$ are a subset of the elements of $T$". 
\end{annotation}

\begin{definition}
\rm Subsumpting rule
$$
\infer{\Gamma \vdash \termtype{t}{T}}{\Gamma \vdash \termtype{t}{S} & \subtyp{S}{T}}.
$$
\end{definition}

\begin{lemma}
\rm Subtype relation satifies reflexivity and transitivity. 
\end{lemma}

\begin{definition}
\rm Let type $Top$ satifies $\subtyp{S}{Top}$ for any type $S$. 
\end{definition}

\begin{definition}
\rm Subtyping rule for records.
$$
\begin{array}{ll}
\subtyp{\{l_1:T_1,l_2:T_2,\cdots,l_n:T_n\}}{\{l_1:T_1,l_2:T_2,\cdots,l_{n+k}:T_{n+k}\}} & \text{width subtyping} \\[0.5em]
\infer{\subtyp{\{l_1:S_1,l_2:S_2,\cdots,l_{n}:S_{n}\}}{\{l_1:T_1,l_2:T_2,\cdots,l_n:T_n\}}}{\forall i.~\subtyp{S_i}{T_i}} & \text{depth subtyping}
\end{array}
$$
\end{definition}

\begin{definition}
\rm Subtyping rule for functions.
$$
\infer{\subtyp{S_1 \to S_2}{T_1 \to T_2}}{\subtyp{T_1}{S_1} & \subtyp{T_2}{S_2}}.
$$
\end{definition}


\begin{annotation}
\rm 关于functuon的subtyping，通常描述为"the function arguments are contravariant and the function results are covariant"，其中covariant的意思就是说如果原本我们有$\subtyp{T_2}{S_2}$做为premise，那么由上述inference rule的conclude里面同样保持这个relation， 即$T_2$在$<:$左边，而$S_2$在右边; 类似地contravariant得到的结果是相反的. 

上述的inference rule可以解释为:
\begin{enumerate}
	\item 一个函数我可以accept相比于original argument type所含elements更多的new argument type，这是safe的. 因为假设function的input不变，我现在可以接受更多的元素，其中原来可以元素也可以cover到，显然是安全的. 
	\item 一个函数我们可以return相比于original result type所含elements更少一点的new argument，这是safe的. 因为假设function的requirements of result不变，我现在$\text{dom}(Res_{new})$是原来$\text{dom}(Res_{old})$的一个子集，原来可以满足前述的requirement，那么现在当然可以满足，显然是安全的. 
\end{enumerate}
\end{annotation}

%\begin{annotation}
%\rm 上面两个lemma更进一步告诉你了一个term的type不唯一了, polymorphism要来了，之前STLC里面保持的properties可能需要重新证明了...
%\end{annotation}

\newpage
\subsection{Properties of Subtyping and Typing}

\begin{annotation}
\rm 当引入subtyping之后我们需要重新研究current type system已经证明过的properties，例如preservation and progress.
\end{annotation}

\begin{lemma}
\rm (\redt{inversion}) 
\begin{itemize}
	\item If $\subtyp{S}{T_1 \to T_2}$, then $S$ has the form $S_1 \to S_2$, with $\subtyp{T_1}{S_1}$ and $\subtyp{S_2}{T_2}$. 
	\item If $\subtyp{S}{\{(l_i:T_i)_{i \in 1\ldots n}\}}$, then  $S$ has the form $\{(k_j:S_j)_{j \in 1 \ldots m}\}$, with $\{{(l_i)}_{i \in 1\ldots n}\}\subseteq\{{(k_j)}_{j \in 1\ldots m}\}$ and for $\forall l_i = k_j. ~ \subtyp{S_i}{T_j}$.
\end{itemize}
\end{lemma}


\begin{lemma}
\rm If $\Gamma \vdash \termtype{\lam{\termtype{x}{S_1}}{s_2}}{T_1 \to T_2}$, then $\subtyp{T_1}{S_1}$ and $\Gamma,\termtype{x}{S_1} \vdash \termtype{s_2}{T_2}$. 
\end{lemma}

\begin{proof}
直接根据typing derivations
$$
\infer{\Gamma \vdash \termtype{\lam{\termtype{x}{S_1}}{s_2}}{T_1 \to T_2}}{\infer{\Gamma \vdash \termtype{\lam{\termtype{x}{S_1}}{s_2}}{S_1 \to T_2}}{\Gamma,\termtype{x}{S_1} \vdash \termtype{s_2}{T_2}} & \infer{\subtyp{S_1 \to T_2}{T_1 \to T_2}}{\subtyp{T_1}{S_1} & \subtyp{T_2}{T_2}}}
$$
关键是将$\Gamma \vdash \termtype{\lam{\termtype{x}{S_1}}{s_2}}{T_1 \to T_2}$看做一个abstraction，它的argument annotation显然和它的type里面的不一样，不能直接拆，因此首先整体要用一下function subtyping.
\end{proof}

\begin{lemma}
\rm If $\Gamma \vdash \termtype{\{{(k_j = s_j)}_{j \in 1\ldots m}\}}{\{{(l_i = T_i)}_{i \in 1\ldots n}\}}$, then $\{{(l_i)}_{i \in 1\ldots n}\}\subseteq\{{(k_j)}_{j \in 1\ldots m}\}$ and $\forall l_i = k_j.~ \Gamma \vdash \termtype{s_j}{T_i}$.
\end{lemma}

\begin{lemma}
\rm (\redt{substitution}) If $\Gamma, x:S \vdash t:T$ and $\Gamma \vdash s:S$, then $\Gamma \vdash [x \mapsto s]t: T$.
\end{lemma}

\begin{theorem}
\rm (\redt{preservation}) If $\Gamma \vdash t:T$ and $t \to t'$, then $\Gamma \vdash t':T$
\end{theorem}

\begin{proof}
证明过程是根据typing rules归纳well-typed $t:T$，这里只需要重点关心new typing rules即可. i.e. representative cases. 
\begin{case}
$$
\infer{\Gamma\vdash t:T}{\Gamma \vdash t:S & \subtyp{S}{T}}
$$
由归纳假设$\Gamma \vdash t:S$ and $t \to t'$, then $\Gamma \vdash t':S$, 此时在对$t':S$用一下subsumption rule，即有$\Gamma \vdash t':T$. 
\end{case}
\end{proof}

\begin{lemma}
\rm (\redt{canonical forms})
\begin{itemize}
	\item If $v$ is closed value of type $T_1 \to T_2$, then $v$ has the form $\lam{x:S_1}{t_2}$.
	\item If $v$ is closed value of type $\{(l_i:T_i)_{i \in 1\ldots n}\}$, then $v$ has the form $\{(k_i:v_i)_{i \in 1\ldots n}\}$, with $\{{(l_i)}_{i \in 1\ldots n}\}\subseteq\{{(k_j)}_{j \in 1\ldots m}\}$.
\end{itemize}
\end{lemma}

\begin{theorem}
\rm (\redt{progress}) If $t$ is closed, well-typed term, then either $t$ is value or else there is some $t'$ with $t \to t'$. 
\end{theorem}

\newpage
\subsection{Bottom Type}

\begin{definition}
\rm Let type $Bot$ satifies $Bot <: T$ for any type $T$.
\end{definition}

\begin{lemma}
\rm There are no closed values of type \emph{Bot}.
\end{lemma}

\begin{proof}

\end{proof}

\newpage
\subsection{Coercion Semantics}


\begin{annotation}
\rm 前面提到的subtyping只不一种针对类型的extension，并没有影响到我们的evaluation过程，但是在实际操作可能会出问题. 假设我们给定$\subtyp{T}{S}$，在实际中$T$和$S$可能有不一样的internal structure，例如常见的bool和int类型，那么在实际evaluation的过程我们应当实现类型转换过程的结构转换. 其中有一种想法就是将带有subtyping语法的language翻译成不带subtyping language，还是使用原来的evaluation过程. 通常来说编译器里面的这种翻译是从high-level language到low-level language的过程. 

这里的翻译过程需要配合subtyping derivation和normal typing derivation. 例如给定一个source language(带subtyping)里面的term $e$和对应的type $T$，我们要将他翻译成target language里面的term $e'$. 那么我们需要将$e$按照derivation把$e$里面的所有subterm也都要翻译到target language里面. 其中涉及到subtyping derivation的翻译，每一个subtyping rule对应一个一个abstraction，例如$\lam{\termtype{x}{T}}{s}\colon T \to S$，我们再将需要做type转换的term作为argument传入就行. 还有一个比较特殊点就是两个language之间的type可能不一致，例如前面提到了$Top$这一类型，对应目标语言里面它就是$Unit$，因此我们还需要构造一下两个语言里面类型的映射. 

下述translation的source language为pure STLC带上record和subtyping，target language为pure STLC只有record和type $Unit$. 
\end{annotation}

\begin{definition}
\rm Function $\dbracket{-}$ of type translation
$$
\begin{array}{ll}
\dbracket{Top} = Unit \\
\dbracket{T_1 \to T_2} = \dbracket{T_1} \to \dbracket{T_2} \\
\dbracket{\{(l_i:T_i)_{i \in 1 \ldots n}\}} = \left\{(l_i:\dbracket{T_i})_{i \in 1 \ldots n}\right\} 
\end{array}
$$
\end{definition}


\begin{definition}
\rm If $C$ is a subtying derivation tree whose conclusion is $\subtyp{S}{T}$, then we have $\mathcal{C}::\subtyp{S}{T}$. Similarly, $\mathcal{D}::\subtyp{S}{T}$ for typing derivation. 
\end{definition}

\begin{definition}
\rm Coercion for subtyping.
$$
\begin{aligned}
&\dbracket{\infer{\subtyp{T}{T}}{}} =  \lam{\termtype{x}{\dbracket{T}}}{x} \\
&\dbracket{\infer{\subtyp{S}{Top}}{}} =  \lam{\termtype{x}{\dbracket{S}}}{unit} \\
&\dbracket{\infer{\subtyp{S}{T}}{C_1:: \subtyp{S}{U} & C_2:: \subtyp{U}{T}}} =  \lam{\termtype{x}{\dbracket{S}}}{\dbracket{C_2}\left(\dbracket{C_1}x\right)} \\
&\dbracket{\infer{\subtyp{S_1 \to S_2}{T_1 \to T_2}}{\mathcal{C}_1:: \subtyp{T_1}{S_2} & \mathcal{C}_2:: \subtyp{S_2}{T_2}}} = \lam{\termtype{f}{\dbracket{S_1 \to S_2}}}{\lam{\termtype{x}{\dbracket{T_1}}}{\dbracket{\mathcal{C}}\left(f\left(\dbracket{C}_1\right)\right)}}\\
&\dbracket{\infer{\subtyp{\{(l_i:T_i)_{i \in 1 \ldots n+k}\}}{\{(l_i:T_i)_{i \in 1 \ldots n}\}}}{}} = \lam{\termtype{r}{\left\{\left(l_i:\dbracket{T_i}\right)_{i \in 1 \ldots n+k}\right\}}}{\{(l_i=r.i)_{i \in 1 \ldots n}\}} \\
&\cdots
\end{aligned}
$$
\end{definition}

\begin{definition}
\rm Function $\dbracket{-}$ of typing derivation
$$
\begin{aligned}
& \dbracket{\infer{\Gamma \vdash \termtype{x}{T}}{\termtype{x}{T} \in \Gamma}} = x \\
& \dbracket{\infer{\Gamma \vdash \termtype{\lam{\termtype{x}{T_1}}{t_2}}{T_1 \to T_2}}{\mathcal{D}:: \Gamma,\termtype{x}{T_1} \vdash \termtype{t_2}{T_2}}} = \lam{\termtype{x}{\dbracket{T_1}}}{\mathcal{D}}\\
&\dbracket{\infer{\Gamma \vdash \termtype{t}{T}}{\mathcal{D}:: \Gamma \vdash \termtype{t}{S} & \mathcal{C}::\subtyp{S}{T}}} = \dbracket{\mathcal{C}}\dbracket{\mathcal{D}}\\
&\cdots
\end{aligned}
$$
\end{definition}


\begin{theorem}
\rm If $\mathcal{D}::\Gamma \vdash \termtype{t}{T}$, then $\dbracket{\Gamma} \vdash \termtype{\dbracket{t}}{\dbracket{T}}$, where $\dbracket{\Gamma}$ is the pointwise extension of the type translation to contexts $\dbracket{\emptyset} = \emptyset$ and $\dbracket{\Gamma,\termtype{x}{T}} = \dbracket{\emptyset},\termtype{x}{\dbracket{T}}$. 
\end{theorem}

\begin{annotation}
\rm 如果我们有关于$\tau_1<:\tau_2$，$\tau_1 <: \tau_3$，$\tau_2<:\tau_4$ and $\tau_3<:\tau_4$的primitive coercions，那么显然关于$\tau_1 <: \tau_4$的subtyping derivation就有两种，有一个疑问是它们翻译到target language经过evaluation之后是不是有一样的结果呢？
\end{annotation}


\begin{definition}
\rm A translation $\dbracket{-}$ from typing derivations in one language to term in another is \redt{coherent} if, for every pair of derivations $\mathcal{D}_1$ and $\mathcal{D}_2$ with same conclusion $\Gamma \vdash \termtype{t}{T}$, the translations $\dbracket{\mathcal{D}_1}$ and $\dbracket{\mathcal{D}_2}$ are behaviorally equivalent terms of the target language.
\end{definition}



\newpage
\section{Type Reconstruction}

\subsection{Type Inference}

\begin{annotation}
\rm 注意到前面讨论typechecker的时候，出现了很多annotations，这些annotations帮助我们解决了一些问题，特别是对abstraction的argument annotation，那么这里要探讨一类typechecker会建立在没有这些annotation的基础上，作为polymorphism的前奏. 
\end{annotation}


\begin{definition}
\rm \cite{typinf}\redt{Type templates} are ductively generated by 
$$
\text{TypeTemp} ::= \tau ~~|~~ \text{Tvar} ~~|~~\text{TypeTemp} \to \text{TypeTemp}. 
$$
where $\tau$ is base type and $\text{Tvar}$ is type variable. 
\end{definition}


\begin{definition}
\rm A \redt{type substitution} $f$ is any function from type variables to type templates. Any type substitution $f$ can be extended to a function between type templates and defined inductively by
$$
f(T) = \left\{
\begin{aligned}
	&T && \text{if}~T~\text{is any basic type}~\tau \\
	&f(T) &&  \text{if}~T~\text{is any type variable}~x \\
	&f(A) \to f(B) &&  \text{if}~T~\text{is}~A \to B~\text{for any two type templates}~A~\text{and}~B 
\end{aligned}
\right.
$$
\end{definition}

\begin{annotation}
\rm 一个type substitution相当于是对缺少annotations的补全，从此我们又可以尝试使用之前的typechecker欢快的玩耍了. 同时一个含type variables的term如果它是well-typed，那么它的所有instance也是well-typed.
\end{annotation}

\begin{theorem}
\rm If $\Gamma \vdash t:T$, then for any type substitution $\sigma$ we have $\sigma\Gamma \vdash \sigma t:\sigma T$. 
\end{theorem}

\begin{annotation}
\rm 上述theorem中的$\sigma t$表示给$t$加上annotation. 
\end{annotation}

\begin{annotation}
\rm Suppose that $t$ is a term containting type variables and $\Gamma$ is an associated context(possibly also containing type variables). There are two quite different questions that can ask about $t$:
\begin{enumerate}
	\item \bluet{for every $\sigma$, do we have $\sigma \Gamma \vdash \sigma t:T$} ? i.e. $\lam{f:X \to X}{\lam{a:X}{f~(f~a)}}$ for any concrete type $T$, the instance is well typed, that is actually parametric polymorphism.
	\item \bluet{for some $\sigma$, do we have $\sigma \Gamma \vdash \sigma t:T$ ?} i.e. $\lam{f:Y}{\lam{a:X}{f~(f~a)}}$ is not typable as it stands, but if replace $Y$ by $X \to X$, we obatin well typed term. 
\end{enumerate}
\end{annotation}


\begin{annotation}
\rm 上面提到的第二类问题就是这里需要探究的问题，尽管我们没有了term里面的存在的annotation，但是term里面依然暗含一些constraints. 例如给定一个application $e_1~e_2$和对应的$\Gamma \vdash e_1 : \tau_1$ and $\Gamma \vdash e_2: \tau_2$, 那么这里就有一个constraint用等式来描述就是$\tau_1 = \tau_2 \to X$，其中$X$是一个fresh variable. 因此我们需要注意到这些constraints来限定可用的substitutions，于是就提出了unifer的概念. 
\end{annotation}

\begin{definition}
\rm A type template to \redt{be more general} than other if the latter can be obtained by applying a substitution to the former. That is, if type templates $A$ is more general than type template $B$, then there exists a substitution $\sigma$ such that $B = \sigma A$.
\end{definition}

\begin{definition}
\rm A substitution $f$ is called an \redt{unifier} of two sequences of type templates $A_1,\cdots,A_n$ and $B_1,\cdots,B_n$ if $f(A_i) = f(B_i)$ for all $i = 1,\cdots,n$. We say that it is the \redt{most general unifier} if given any other unifier $g$ exists a substitution $h$ such that $g = h \circ f$. 
\end{definition}

\begin{annotation}
\rm 这里的the most general unifier刻画应该是这样一个性质，
\[
% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAEEQBfU9TXfIRRkATFVqMWbAELdeIDNjwEiI0gEZx9Zq0QgAwnL5LBRACwatk3SAAi3cTCgBzeEVAAzAE4QAtkjIQHAgkNQkdNgAxIxBvPyR1amDQ6m0pPWjqBjoAIxgGAAV+ZSEQLyxnAAscGLj-REDkxABmajywKCRmwLSbAHFan3rEoJCWtpgOpABabtTrNgGs3PyikxU9cqqank8hlNGu+Yi9AAkHLiA
\begin{tikzcd}
A \arrow[rrd, "f"] \arrow[rrrrd, "g", bend left]    &  &                   &  &   \\
                                                    &  & C \arrow[rr, "h"] &  & D \\
B \arrow[rru, "f"'] \arrow[rrrru, "g"', bend right] &  &                   &  &  
\end{tikzcd}
\]
如果存在两种unifier，那么显然它们是上述这种关系，当考虑所有unifier的时候，就存在一个most general unifier(？). 
\end{annotation}

\begin{lemma}
\rm (\redt{how to construct the most general unifier}) If an unifier of ${A_1,\cdots,A_n}$ and $B_1,\cdots,B_n$ exists, the most general unifier is $\text{unify}(A_1,\cdots,A_n,B_1,\cdots,B_n)$, which is partially defined by induction as follow, where $x$ is any type variable.
\begin{enumerate}
	\item $\text{unify}(x;x) = \text{id}$ and $\text{unify}(\tau;\tau) = \text{id}$;
	\item $\text{unify}(x;B) = (x \to B)$, the substitution that only changes $x$ by $B$; if $x$ does not occur in $B$. The algorithm fails if $x$ occurs in $B$;
	\item $\text{unify}(A;x)$ is defined symmetrically;
	\item $\text{unify}(A \to A'; B \to B') = \text{unify}(A,A';B,B')$;
	\item $\text{unify}(A,A_1,\cdots,A_n;B,B_1,\cdots,B_n) = f \circ g$ where $g = \text{unify}(A_1,\cdots,A_n;B_1,\cdots,B_n)$ and $f = \text{unify}(g(A);g(B))$.
	\item unify fails in any other case.
\end{enumerate}
\end{lemma}

\begin{proof}
\rm 这里需要证明3个部分:(1 上述描述的确实是一个unifier (2 the most general unifier (3 termination. 

对于(3 termination, 我们需要model一个degree关于当且需要解决的constraints，这个degree用两个维度来表示: the number of distinct type variables和 the number of whole types. 对于上述算法的每一步只会出现两种情况: (1 要么直接结束了 i.e. step1或者step6 (2 要么就是degree在减少 i.e. step2,3,5比较明显，step4中减少了两个arrow type. step 5相当于从一堆constraints里面取一个出来接近. 因此我们的degree是finite，最终算法会停止.

对于(2 还是通常手法hypothesis induction，对constraints的规模做归纳. Base: 对于empty sequence, unfier实际上得到的是一个identity $\text{id}$, 那么对于任意的substitution $\delta$，都有$\delta = \delta \circ \text{id}$. Induction: 当n+1规模时，即$\mathcal{C} = (A, B) \cup \mathcal{C}'$, 其中$\mathcal{C}' = (A_1,\cdots,A_n; A_1,\cdots,A_n)$. 根据假设我们有$\sigma' = \text{unify}(\mathcal{C}')$，这里要对$(\sigma' A,\sigma' B)$的结构继续按照unfier算法讨论，现在仅考虑$\sigma' A = x$时，即step2. 对于任意$\delta$ unifies $\mathcal{C}$, 也有$\delta$ unifies $\mathcal{C}'$, 那么这里存在$\gamma$使得$\delta = \gamma \circ \sigma'$, 这里提前假设给我们带来的. 而这里的$\sigma = \text{unify}(\mathcal{C}) =  (\sigma' A \to \sigma' B) \circ \sigma'$, 要是能证明
$$
\delta = \gamma \circ (\sigma' A \to \sigma' B) \circ \sigma'
$$
就好了. 对于任意的type variable$x$, 当$\sigma' x \neq \sigma'A$时，有$(\gamma \circ (\sigma' A \to \sigma' B) \circ \sigma')x = (\gamma \circ \sigma') x = \delta x$; 当$\sigma'x = \sigma 'A$时，有
$$
(\gamma \circ (\sigma' A \to \sigma' B) \circ \sigma')x = \gamma(\sigma' B) = \delta(B),
$$
而$\delta(A) = \delta(B)$, 因此$\delta(B) =(\gamma\circ \sigma') A = \delta(x)$. 
\end{proof}

\begin{annotation}
\rm 你可能会在评估unifier算法的时候，想如果不同的type templates含有相同的type variables是否出现问题？ 只要对应type templates，不出现上面提到的那种问题，就不会有问题. 因为我们处理的过程是one by one, 那么处理下一个的时候，前面的所有已经被某个$\sigma$给弄成一样了，这样其中一个变，全部都得变，最后还是一样的. 
\end{annotation}

\begin{theorem}
\rm (\redt{type inference}) The function $\text{typeinfer}(M,B)$, partially defined as follows, finds the most general substitution $\sigma$ such that $x_1:\sigma A_1,\cdots,x_n:\sigma A_n \vdash M:\sigma B$ is a valid typing judgment if it exists; and fails otherwise.
\begin{enumerate}
	\item (var) $\text{typeinfer}(\Gamma,x_i:A_i \vdash x_i:B) = \text{unify}(A_i,B)$;
	\item (app) $\text{typeinfer}(\Gamma \vdash MN:B) = f \circ g$, where $g = \text{typeinfer}(\Gamma \vdash M:X\to B)$ and $f = \text{typeinfer}(g\Gamma\vdash N:gX)$ for a fresh type variable $X$. 
	\item (abs) $\text{typeinfer}(\Gamma \vdash \lam{x}{M:B}) = f \circ g$ where $g = \text{unify}(B,z \to z')$ and $f = \text{typeinfer}(g\Gamma, x:gz \vdash M:gz')$ for fresh type variables $z,z'$. 
\end{enumerate}
\end{theorem}

\begin{annotation}
\rm 关于type inference有两种方法，但实质都是一样的. 
\begin{enumerate}
	\item 我们上述提到的方法实际上在一边构造constraints of types, 同时也在解决这些constrains. 
	\item 另外一种方法是首先把某个term对应的constraints都构造出来，最后我们可以得到一个关于该term的一个shape of type $S$，然后我们再去找到满足该constraints的$\sigma$，最后对应term的type为$\sigma S$. 构造constraints的过程采用inference rules. 
\end{enumerate}
无论哪种方法，我们都需要证明该算法的soundness和completeness. 其中
\begin{enumerate}
	\item soundness指该算法得到的$\sigma$和$\sigma B$是well-defined.
	\item completeness指任意一个满足上述$\sigma$，有一个利用上述算法得到的$\sigma'$使得$\sigma B = \sigma' B$. 
\end{enumerate}
\end{annotation}


\begin{definition}
\rm Suppose $\Gamma \vdash M:\pi$, where $pi$ is type template. If every possible type $T$ for $M$ is a instance of $\pi$, that is, $T = \sigma \pi$, we say $\pi$ is a \redt{principle type} of $M$.    
\end{definition}

\begin{theorem}
\rm If $\Gamma \vdash M:B$ has possible solution, then $M$ has principle type. 
\end{theorem}


\newpage
\subsection{Let Polymorphism}

\begin{annotation}
\rm 如果想要实现如下语法
$$
\begin{aligned}
&\text{let}~\text{double} = \lam{f:\tau \to \tau}{\lam{x:\tau}{f(f(x))}}~\text{in} \\
&\text{let}~ a = ~\text{double}~ (\lam{x:nat}{\text{succ}~(\text{succ}~x)})~ 1~\text{in} \\
&\text{let}~ b = ~\text{double}~ (\lam{x:bool}{x})~false~\text{in}~\cdots
\end{aligned}
$$
在现有let语义下有些问题，这里会给出两个矛盾的constraints即
$$
\tau \to \tau = nat \to nat, \,\tau \to \tau = bool \to bool.  
$$
出现这种问题的原因在于let本身的typing inference rule
$$
\infer[\text{T}{\tiny{-}}\textsc{Let}]{\Gamma \vdash \text{let}~x  = e_1~\text{in}~e_2:\tau_2}{\Gamma \vdash e_1:\tau_1 & \Gamma, x:\tau_1 \vdash e_2:\tau_2}
$$
这里将$e_1$和$x$的type绑定起来了，因此首先我们首先去掉这种绑定状态.
\end{annotation}

\begin{definition}
\rm Let-polymorphism typing rule as follow
$$
\infer[\text{T}{\tiny{-}}\textsc{LetPoly}]{\Gamma \vdash \text{let}~x  = e_1~\text{in}~e_2:\tau_2}{\Gamma \vdash [x \to e_1]e_2:\tau_2}
$$
\end{definition}


\begin{annotation}
\rm 
这样我们直接将let-body中的$x$替换成$e_1$, 去掉了单独关于$e_1$的单独typechecking, 等到它在let-body中出现的时候在考虑其type. 

这样还是有一点问题就是double里面还是存在argument annotation, 还是解决不了问题，我们得想办法把不同case里面的argument annotation用不同的variables表示. 这里我们在语法上引入不带annotation的lambda abstraction，在parser typing阶段再给assign一个annotation. 这样做的好处就是对同一个abstraction，我们能拷贝不同annotation的abstraction.  
\end{annotation}

\begin{definition}
\rm Typing rule for unannotated abstration.
$$
\infer{\Gamma \vdash \lam{x}{e_1}:A \to B}{X \notin \mathcal{X} & \Gamma, x: A \vdash e_1:B |_{\mathcal{X}}}
$$
where $\mathcal{X}$ represents type variable used in $\Gamma$,\,$e_1$ and $B$. 
\end{definition}

\begin{annotation}
\rm 现在就可以正常工作了, 但是还有一些不那么明显的问题:
\begin{enumerate}
	\item 如果$e_1$没有在let-body中出现，那么它永远不会被typecheck. 我们可以改写一下let-poly来解决这个问题:
	$$
	\infer[\text{T}{\tiny{-}}\textsc{LetPoly}]{\Gamma \vdash \text{let}~x  = e_1~\text{in}~e_2:\tau_2}{\Gamma \vdash [x \to e_1]e_2:\tau_2 & \Gamma \vdash e_1:\tau_1}
	$$
	\item 因为$e_1$将会被替换到let-body每一处它出现的地方，那么每个地方都会经历typecheck, 无论其是否含有type variables. 我们最好首先对$e_1$做一个simplify，可以先把$e_1$提出来，构造关于$e_1$的principle type $\pi$; 然后generalize $\pi$里面出现的type variables $X_1,\cdots,X_2$, 注意不包含$\Gamma$里面出现的type variables，仅仅是对$e_1$的刻画，利用这些type variables构造一个type scheme $\forall X_1,\cdots,X_2 \pi$; 最后开始typecheck let-body, 对于每一个$x$出现的地方，我们都实例化一下这个type scheme，即给里面每个type variables都assign一个fresh variables得到一个type，再把这个type给$x$. 
\end{enumerate}
\end{annotation}

\newpage
\begin{thebibliography}{00}
\bibitem{typinf} Mario Román García. Category Theory and Lambda Calculus. \url{https://mroman42.github.io/ctlc/ctlc.pdf}
\end{thebibliography}
\end{document}