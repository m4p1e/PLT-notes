\documentclass{article}

\usepackage{ctex}
\usepackage{tikz}
\usetikzlibrary{cd}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}

%\usepackage{unicode-math}


\usepackage[textwidth=18cm]{geometry} % 设置页宽=18

\usepackage{blindtext}
\usepackage{bm}
\parindent=0pt
\setlength{\parindent}{2em} 
\usepackage{indentfirst}

\usepackage{listings}
%\usepackage{minted}% hightlighting

\usepackage{proof} % infer

\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\color{blue}\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[hang]{\color{red}\Large\bfseries}{}{0em}{}
%\setcounter{secnumdepth}{1} %section 序号

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{exercise}{Exercise}[section]
\newtheorem{annotation}[theorem]{Annotation}

\newcommand*{\xfunc}[4]{{#2}\colon{#3}{#1}{#4}}
\newcommand*{\func}[3]{\xfunc{\to}{#1}{#2}{#3}}

\newcommand\Set[2]{\{\,#1\mid#2\,\}} %集合
\newcommand\SET[2]{\Set{#1}{\text{#2}}} %

\begin{document}
\title{Types and Programming Language}
\author{枫聆}
\maketitle
\tableofcontents

\newpage
\section{Introduction}

\begin{definition}
\rm A {\color{red} type system} is a tractable syntactic method for proving the absence of certain program behaviors by classlying phrases according to the kinds of value they compute.
\end{definition}

{\color{blue} type system是一种用于证明某些确定的程序行为不会发生的方法，它怎么做呢？通过它们计算出值的类型来分类, 有点抽象... 我想知道the kinds of value they compute是什么？ 如何分类？ 分类之后接下来该怎么做？}

\begin{annotation}
\rm Being static, type systems are necessarily also {\color{red}conservative}: they can categorically prove the absence of some bad program behaviors， but they cant prove their presence.
\end{annotation}

\lstset{language=C,
    basicstyle=\ttfamily,
    keywordstyle=\bfseries,
    showstringspaces=false,
    morekeywords={include, printf}
}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=2, numbersep=5pt}

\begin{example}
\rm
\begin{lstlisting}
if <complex test> then 5 else <type error>
\end{lstlisting}
{\color{blue} 上面这个annotation在说type system只能证明它看到的一些bad program behavior不会出现，但是它们可能会reject掉一些runtime time阶段运行良好的程序，例如在runtime阶段上面的else可能永远都不会进. 即type system无法证明它是否真的存在}.
\end{example}

\newpage
\section{Untyped Systems}

\subsection{Syntax}

\begin{definition}
\rm The set of terms is the smallest set $\mathcal{T}$ such that 
\begin{enumerate}
	\item $\{\text{true},\text{false},0\} \subseteq \mathcal{T}$;
	\item if $t_1 \in \mathcal{T}$, then $\{\text{succ}\ t_1, \text{pred}\ t_1, \text{iszero}\ t_1\} \subseteq \mathcal{T}$;
	\item if $t_1 \in \mathcal{T}, t_2 \in \mathcal{T}, t_3 \in \mathcal{T}$, then $\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!} \in \mathcal{T}$.
\end{enumerate}
\end{definition}

\begin{definition}
\rm The set of terms is defined by the following rules:
$$
\begin{array}{ccc}
\text{true} \in \mathcal{T}  & \text{false} \in \mathcal{T} & 0 \in \mathcal{T} \\
\infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} & \infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} & \infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} \\
& \infer{\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!}}{ t_1 \in \mathcal{T} & t_2 \in \mathcal{T} & t_3 \in \mathcal{T}} &\\ 
\end{array}
$$
\end{definition}

\begin{definition}
\rm For each natural number $i$, define a S(X) as follow:
$$
\begin{aligned}
S_0(X)  &= X \\
S_1(X)  &= \Set{\text{succ}\ t,\text{prev}\ t,\text{iszero}\ t }{t \in X} \cup \Set{\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!}}{t_1,t_2,t_3 \in X} \\
&\vdots \\
S_{i+1}(X) &= S(S_i(X)).
\end{aligned}
$$
\end{definition}

\begin{proposition}
\rm $\mathcal{T} = \bigcup_{i = 0}^{\omega} S_i(\{\text{true},\text{false},0\})$.
\end{proposition}

\begin{proof}
我们设$\bigcup_{i = 0}^{\omega} S_i(\{\text{true},\text{false},0\}) = S$和$\{\text{true},\text{false},0\} = T$，证明过程分两步走(1)$S$ follow Definition2.1 (2) $S$ is smallest.

proof (1). $\{\text{true},\text{false},0\} \in S$这是显然的. 若$t_1 \in S$，那么$t_1 \in S_i(T)$，考虑$\text{succ}\ t_1, \text{pred}\ t_1, \text{iszero}\ t_1 \in S_{i+1}(T)$.  同理Definiton2.1(3).

proof (2). 考虑任意follow Definition2.1的集合$S'$，我们需要证明$S \subseteq S'$.  我们考虑任意的$S_i \subseteq S$，若都有$S_i \subseteq S'$，那么则有$S \subseteq S'$. 这里我们使用induction来证明，首先有$S_0(T) \subseteq S'$，假设$S_n(T) \subseteq S'$. 那么考虑$S_{n+1}(T) = S(S_n(T))$，任意的$t_1，t_2, t_3 \in S_n(T)$，那么Definition2.1(1)(2)(3)得到的结果都是属于$S'$，因此$S_{n+1}(T) \subseteq S'$.  
\end{proof}

\newpage
\subsection{Semantic Styles}

%https://www.zhihu.com/question/23861885
\begin{annotation}
\rm 有三种方法来形式化语义:
\begin{enumerate}
	\item Operational semantics(操作语义) 定义程序是如何运行的？ 所以你需要一个abstract machine来帮助解释，之所以abstract是因为它里面的mechine code就是the term of language. 其中又分为两种类型，big-step和small-step.
	\item Denotational semantics(指称语义) 就是给定一个semantic domain和一个interpretaion function，通过这个function把term映射到semantic domain里面，这个domain里面可能是一堆数学对象. 它的优势是对求值进行抽象，突出语言的本质. 我们可以在semantic domain里面做运算，只要interpretation function建立的好，运算结果可以表征程序本身的性质.
	\item Axiomatic semantics(公理语义) 拿axioms堆起来的程序？ 类似Hoare logic.
	\item Alegbraic semantics(代数语义) 把程序本身映射到某个代数结构上，转而研究这个代数?
\end{enumerate}
\end{annotation}

\newpage
\subsection{Evaluation}

\begin{annotation}
\rm 这一章在讲operational semantic of boolean expression, 这个过程会清晰的告诉你我们求值的结果是什么？当我们对term求值时，term之间的转换规则应该是什么？ 既然有了转换，那么一定有终止的时候，这个终止的时刻就是我们求值的结果，那我们要问什么时候停止呢？ 开头的表格告诉了关于前面这些问题的答案. 当然有一些东西也没有出现在表格里面，但是它们同样重要，例如不能在对false，true，0这些东西再求值；求值的顺序等等.
\end{annotation}


\begin{definition}
\rm An instance of an inference rule is obtained by consistently replacing each metavariable by the same term in the rule’s conclusion and all its premises (if any).

{\color{blue} 一个推导规则的实例，就是把里面的metavariable替换成具体的terms，但是一定需要注意对应关系}.
\end{definition}


\begin{definition}

\end{definition}

\end{document}