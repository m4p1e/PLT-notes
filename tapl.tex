\documentclass{article}

\usepackage{ctex}
\usepackage{tikz}
\usetikzlibrary{cd}

%冲突nthm
%\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}

%\usepackage{unicode-math}
%\usepackage{chngcntr}
\usepackage{hyperref} %url
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }


\usepackage[textwidth=18cm]{geometry} % 设置页宽=18

\usepackage{blindtext}
\usepackage{bm}
\parindent=0pt
\setlength{\parindent}{2em} 
\usepackage{indentfirst}

\usepackage{listings}
%\usepackage{minted}% hightlighting

\usepackage{proof} % infer

\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\color{blue}\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[hang]{\color{red}\Large\bfseries}{}{0em}{}
%\setcounter{secnumdepth}{1} %section 序号


\usepackage[thmmarks, thref, amsmath]{ntheorem}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}

\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{exercise}{Exercise}[section]
\newtheorem{annotation}[theorem]{Annotation}

\theoremheaderfont{\itshape}
\theorembodyfont{\upshape}
\newtheorem{case}{Case}

\theoremstyle{nonumberplain}
\theoremheaderfont{\scshape}
\theorembodyfont{\upshape}
\theoremsymbol{\scshape Q. E. D.}
\theorempostwork{\setcounter{case}{0}}
\newtheorem{proof}{Proof}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{case}{Case}
%\newtheorem{subcase}{Case}
%\numberwithin{subcase}{case}

\newcommand*{\xfunc}[4]{{#2}\colon{#3}{#1}{#4}}
\newcommand*{\func}[3]{\xfunc{\to}{#1}{#2}{#3}}

\newcommand\Set[2]{\{\,#1\mid#2\,\}} %集合
\newcommand\SET[2]{\Set{#1}{\text{#2}}} %

\newcommand{\inl}[1]{\ensuremath{\text{inl}~#1}}
\newcommand{\inr}[1]{\ensuremath{\text{inr}~#1}}
\newcommand{\fold}[1]{\ensuremath{{fold}_{#1}}}
\newcommand{\unfold}[1]{\ensuremath{{unfold}_{#1}}}
\newcommand{\lam}[2]{\ensuremath{\lambda #1\ldotp #2}} %lamx.y
\newcommand{\pair}[1]{\ensuremath{\left\langle#1\right\rangle}}
\newcommand{\projone}[1]{\ensuremath{#1.1}}
\newcommand{\projtwo}[1]{\ensuremath{#1.2}}
\newcommand{\caseof}[3]{\ensuremath{{\textbf{case}}~#1~{\textbf{of}}~\inl{x_1}\mapsto #2\mid\inr{x_2}\mapsto #3}}
\newcommand{\Lam}[2]{\ensuremath{\Lambda #1\ldotp #2}}
\newcommand{\pack}[3]{\ensuremath{{pack}~\pair{#1,#2}~{as}~#3}}
\newcommand{\unpack}[4]{\ensuremath{{unpack}~#1~{as}~\pair{#2,#3}~{in}~#4}}

\newcommand{\singletype}[1]{\text{#1}}
\newcommand{\termtype}[2]{\ensuremath{#1:#2}}
\newcommand{\type}[3]{\ensuremath{ \left\{#1:#2\relmiddle|#3 \right\}}}
\newcommand{\matgen}[2]{\ensuremath{\mu #1\ldotp#2}} %ux.y
\newcommand{\mat}[0]{\matgen{\alpha}{\tau}} %ua.t
\newcommand{\fatgen}[2]{\ensuremath{\forall #1\ldotp#2}}
\newcommand{\fat}[0]{\fatgen{\alpha}{\tau}}
\newcommand{\eatgen}[2]{\ensuremath{\exists #1\ldotp#2}}
\newcommand{\eat}[0]{\eatgen{\alpha}{\tau}}
\newcommand{\fatgent}[2]{\ensuremath{\trgb{\forall} #1\ldotp#2}}
\newcommand{\fatt}[0]{\fatgent{\alpt}{\tat}}
\newcommand{\eatgent}[2]{\ensuremath{\trgb{\exists} #1\ldotp#2}}
\newcommand{\eatt}[0]{\eatgent{\alpt}{\tat}}

\newcommand{\fail}[0]{\mi{fail}}

\newcommand{\bnfdef}[0]{\ensuremath{\mathrel{::=}}} %::=
\newcommand{\term}[1]{\ensuremath\mathsf{#1}}
\newcommand{\true}{\term{true}}
\newcommand{\false}{\term{false}}
\newcommand{\ifelse}[3]{\ensuremath{\textbf{if}~#1~\textbf{then}~#2~\textbf{else}~#3}}
\newcommand{\succt}[1]{\term{succ}~#1}
\newcommand{\pred}[1]{\term{pred}~#1}
\newcommand{\iszero}[1]{\term{iszero}~#1}
\newcommand{\seq}[2]{#1;#2}


\newcommand{\redt}[1]{\textcolor{red}{#1}}
\newcommand{\bluet}[1]{\textcolor{blue}{#1}}

\begin{document}
\title{Types and Programming Language}
\author{枫聆}
\maketitle
\tableofcontents

\newpage
\section{Introduction}

\begin{definition}
\rm A {\color{red} type system} is a tractable syntactic method for proving the absence of certain program behaviors by classlying phrases according to the kinds of value they compute.
\end{definition}

{\color{blue} type system是一种用于证明某些确定的程序行为不会发生的方法，它怎么做呢？通过它们计算出值的类型来分类, 有点抽象... 我想知道the kinds of value they compute是什么？ 如何分类？ 分类之后接下来该怎么做？}

\begin{annotation}
\rm Being static, type systems are necessarily also {\color{red}conservative}: they can categorically prove the absence of some bad program behaviors， but they cant prove their presence.
\end{annotation}

\lstset{language=C,
    basicstyle=\ttfamily,
    keywordstyle=\bfseries,
    showstringspaces=false,
    morekeywords={include, printf}
}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=2, numbersep=5pt}

\begin{example}
\rm
\begin{lstlisting}
if <complex test> then 5 else <type error>
\end{lstlisting}
{\color{blue} 上面这个annotation在说type system只能证明它看到的一些bad program behavior不会出现，但是它们可能会reject掉一些runtime time阶段运行良好的程序，例如在runtime阶段上面的else可能永远都不会进. 即type system无法证明它是否真的存在}.
\end{example}

\newpage
\section{Untyped Systems}

\subsection{Syntax}

\begin{definition}
\rm The set of terms is the smallest set $\mathcal{T}$ such that 
\begin{enumerate}
	\item $\{\text{true},\text{false},0\} \subseteq \mathcal{T}$;
	\item if $t_1 \in \mathcal{T}$, then $\{\text{succ}\ t_1, \text{pred}\ t_1, \text{iszero}\ t_1\} \subseteq \mathcal{T}$;
	\item if $t_1 \in \mathcal{T}, t_2 \in \mathcal{T}, t_3 \in \mathcal{T}$, then $\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!} \in \mathcal{T}$.
\end{enumerate}
\end{definition}

\begin{definition}
\rm The set of terms is defined by the following rules:
$$
\begin{array}{ccc}
\text{true} \in \mathcal{T}  & \text{false} \in \mathcal{T} & 0 \in \mathcal{T} \\
\infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} & \infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} & \infer{\text{succ} t_1 \in \mathcal{T}}{t_1 \mathcal{T}} \\
& \infer{\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!}}{ t_1 \in \mathcal{T} & t_2 \in \mathcal{T} & t_3 \in \mathcal{T}} &\\ 
\end{array}
$$
\end{definition}

\begin{definition}
\rm For each natural number $i$, define a S(X) as follow:
$$
\begin{aligned}
S_0(X)  &= X \\
S_1(X)  &= \Set{\text{succ}\ t,\text{prev}\ t,\text{iszero}\ t }{t \in X} \cup \Set{\text{\lstinline[mathescape]!if $t_1$ then $t_2$ else $t_3$!}}{t_1,t_2,t_3 \in X} \\
&\vdots \\
S_{i+1}(X) &= S(S_i(X)).
\end{aligned}
$$
\end{definition}

\begin{proposition}
\rm $\mathcal{T} = \bigcup_{i = 0}^{\omega} S_i(\{\text{true},\text{false},0\})$.
\end{proposition}

\begin{proof}
我们设$\bigcup_{i = 0}^{\omega} S_i(\{\text{true},\text{false},0\}) = S$和$\{\text{true},\text{false},0\} = T$，证明过程分两步走(1)$S$ follow Definition2.1 (2) $S$ is smallest.

proof (1). $\{\text{true},\text{false},0\} \in S$这是显然的. 若$t_1 \in S$，那么$t_1 \in S_i(T)$，考虑$\text{succ}\ t_1, \text{pred}\ t_1, \text{iszero}\ t_1 \in S_{i+1}(T)$.  同理Definiton2.1(3).

proof (2). 考虑任意follow Definition2.1的集合$S'$，我们需要证明$S \subseteq S'$.  我们考虑任意的$S_i \subseteq S$，若都有$S_i \subseteq S'$，那么则有$S \subseteq S'$. 这里我们使用induction来证明，首先有$S_0(T) \subseteq S'$，假设$S_n(T) \subseteq S'$. 那么考虑$S_{n+1}(T) = S(S_n(T))$，任意的$t_1，t_2, t_3 \in S_n(T)$，那么Definition2.1(1)(2)(3)得到的结果都是属于$S'$，因此$S_{n+1}(T) \subseteq S'$.  
\end{proof}

\begin{definition}
\rm The \redt{depth} of a term $t$ is the smallest $i$ such that $t \in S_i(X)$. 
\end{definition}

\begin{definition}
\rm If a term $\term{t} \in S_i(X)$, then all of its \redt{immediate subterms} must be in $S_{i-1}(X)$. 
\end{definition}


\begin{theorem}
\rm \redt{Structural induction} Suppose $P$ is a predicate on terms. If for each term $\term{s}$, given $P(\term{r})$ for all immediate subterms $\term{r}$ of $\term{s}$, we can show $P(\term{s})$, then $P(\term{s})$ holds for all $\term{s}$. 
\end{theorem}



\subsection{Induction}


\newpage
\subsection{Semantic Styles}

%https://www.zhihu.com/question/23861885
\begin{annotation}
\rm 有三种方法来形式化语义:
\begin{enumerate}
	\item Operational semantics(操作语义) 定义程序是如何运行的？ 所以你需要一个abstract machine来帮助解释，之所以abstract是因为它里面的mechine code就是the term of language. 其中又分为两种类型，big-step和small-step.
	\item Denotational semantics(指称语义) 就是给定一个semantic domain和一个interpretaion function，通过这个function把term映射到semantic domain里面，这个domain里面可能是一堆数学对象. 它的优势是对求值进行抽象，突出语言的本质. 我们可以在semantic domain里面做运算，只要interpretation function建立的好，运算结果可以表征程序本身的性质.
	\item Axiomatic semantics(公理语义) 拿axioms堆起来的程序？ 类似Hoare logic.
	\item Alegbraic semantics(代数语义) 把程序本身映射到某个代数结构上，转而研究这个代数?
\end{enumerate}
\end{annotation}

\newpage
\subsection{Evaluation}

\begin{annotation}
\rm 这一章在讲operational semantic of boolean expression, 这个过程会清晰的告诉你我们求值的结果是什么？当我们对term求值时，term之间的转换规则应该是什么？ 既然有了转换，那么一定有终止的时候，这个终止的时刻就是我们求值的结果，那我们要问什么时候停止呢？ 开头的表格告诉了关于前面这些问题的答案. 当然有一些东西也没有出现在表格里面，但是它们同样重要，例如不能在对false，true，0这些东西再求值；求值的顺序等等.
\end{annotation}


\begin{definition}
\rm An instance of an inference rule is obtained by consistently replacing each metavariable by the same term in the rule’s conclusion and all its premises (if any).

{\color{blue} 一个推导规则的实例，就是把里面的metavariable替换成具体的terms，但是一定需要注意对应关系}.
\end{definition}


\begin{definition}
\rm Evaluation relations: 一步求值 (基本evaluation relation)；多步求值 (evaluation relation的传递闭包产生的新的relation， 这个relation包含原来的所有evaluation relation);
\end{definition}


\begin{definition}
\rm A term t is in normal form if no evaluation rule applies to it.

{\color{blue} 范式是一个term无法继续求值的状态}.
\end{definition}

\begin{definition}
\rm A closed term is stuck if it is in normal form but not a value.

{\color{blue} 受阻项是一种特殊的范式，这个范式不是一个合法的值}.
\end{definition}


\newpage
\subsection{The Untyped Lambda-Calculus}

\begin{annotation}
\rm {\color{red} 过程抽象} Procedural (or functional) abstraction is a key feature of essentially all pro-gramming languages
\end{annotation}

\begin{definition}
\rm {\color{red} $\lambda$演算的定义} The lambda-calculus (or -calculus) embodies this kind of function defi-nition and application in the purest possible form. In the lambda-calculus everything is a function: the arguments accepted by functions are themselves functions and the result returned by a function is another function.

The syntax of the lambda-calculus comprises just three sorts of terms.
$$
\begin{aligned}
\term{t} \bnfdef & \\
&\ \term{x} \\
&\ \lam{x}{\term{t}} \\
&\ \term{t}\ \term{t}.
\end{aligned}
$$
A variable $\term{x}$ by itself is a term; the abstraction of a variable $\term{x}$ from a term $\term{t_1}$, written $\lam{x}{t_1}$, is a term; and the application of a term $\term{t_1}$ to another term $\term{t_2}$, written $\term{t_1}\ \term{t_2}$, is a term.

{\color{blue} 在 pure lambda-calculus里面所有的terms都是函数，第一个term表示变量，第二个term表示abstraction，第三个term表示application. 言下之意一个lambda函数的参数和返回值也都是函数}. 
\end{definition}

\begin{definition}
\rm {\color{red}两个重要的约定} First, application associates to the left, means
$$
\term{s}~\term{t}~\term{u} = (\term{s}~\term{t})~\term{u}.
$$
Second, the bodies of abstractions are taken to extend as far to the right
as possible.
$$
\lam{x}{\lam{y}{x~y~x}} = \lam{x}{(\lam{y}{((x~y)~x)})}.
$$

{\color{blue} 第一个是说函数的apply操作是左结合，第二是说lambda函数的抽象体尽量向右扩展}.
\end{definition}

\begin{definition}
\rm {\color{red} 作用域scope} An occurrence of the variable x is said to be {\color{red} bound} when it occurs in the body $\term{t}$ of an abstraction $\lam{x}{\term{t}}.$(More precisely, it is bound by this abstraction.
Equivalently, we can say that $\lambda x$ is a binder whose scope is $\term{t}$.) An occurrence of $x$ is {\color{red} free} if it appears in a position where it is not bound by an enclosing abstraction on $x$. i.e. $x$ in $\lam{y}{x\ y}$ and $x\ y$ are free. 

A term with no free variables is said to be {\color{red} closed}; closed terms are also called {\color{red}combinators}. The simplest combinator, called the identity function,
$$
\term{id} = \lam{x}{x}.
$$
\end{definition}

\begin{definition}
\rm {\color{red} $\alpha$等价} A basic form of equivalence, definable on lambda terms, is alpha equivalence. It captures the intuition that the particular choice of a bound variable, in an abstraction, does not (usually) matter. 
$$
\lam{x}{x} \cong \lam{y}{y}
$$

{\color{blue} 简而言之，同时对一个lambda函数替换所有bound variable得到的term是等价的, $\alpha$变换在进行$\beta$规约的时候，用于解决变量名冲突特别有用）}.
\end{definition}

\begin{definition}
\rm {\color{red} 操作语义} Each step in the computation consists of rewriting an application whose left-hand component is an abstraction, by substituting the right-hand component for the bound variable in the abstraction's body.Graphically, we write
$$
(\lam{x}{\term{t_{12}}})~\term{t_2} \rightarrow \left[ x \mapsto \term{t_2} \right] \term{t_{12}},
$$
where $\left[ x \mapsto \term{t_2} \right]$ means "the term obtainted by replacing all free occurences of $x$ in $\term{t_{12}}$ by $t_2$". 
\end{definition}

\begin{definition}
\rm {\color{red} 可约表达式} A term of the form $(\lam{x}{\term{t_{12}}})~\term{t_2}$ is called {\color{red} redex} (reducible expression), and the operation of rewriting a redex according to the above rule is called {\color{red} $\beta$-reduction}.
\end{definition}

%https://en.wikipedia.org/wiki/Evaluation_strategy
\begin{definition}
\rm {\color{red} 几种规约策略} Each strategy defines which redex or redexes in a term can fire on the next step of evaluation. 
\begin{enumerate}
	\item Undering {\color{red} full $\beta$-reduction}, any redex may be reduced at any time. i.e., consider the term
	$$
	(\lam{x}{x})~((\lam{x}{x})~(\lam{z}{(\lam{x}{x})~z})),
	$$
	we can write more readably as $\term{id}~(\term{id}(\lam{z}{\term{id}}~z))$. This term contains three redexes:
	$$
	\begin{aligned}
	\underline{\term{id}~(\term{id}~(\lam{z}{\term{id}}~z))} \\
	\term{id}~(\underline{\term{id}~(\lam{z}{\term{id}}~z)}) \\
	\term{id}~(\term{id}~(\lam{z}{\underline{\term{id}~z}}))
	\end{aligned}
	$$
	under full $\beta$-reduction, we might choose, for example, to begin with the innermost index, then do the one in the middle, then the outermost:
	$$
	\begin{aligned}
	&\term{id}~(\term{id}~(\lam{z}{\underline{\term{id}~z}})) \\
	\rightarrow & \term{id}~(\underline{\term{id}~(\lam{z}{z})}) \\
	\rightarrow & \underline{\term{id}~(\lam{z}{z})} \\
	\rightarrow & \lam{z}{z} \\
	\nrightarrow
	\end{aligned}
	$$
	\item Undering the {\color{red} normal order} strategy, the leftmost, outermost redex is always reduced first. Under this strategy, the term above would be reduced as follows
	$$
	\begin{aligned}
	& \underline{\term{id}~(\term{id}~(\lam{z}{\term{id}~z}))} \\
	\rightarrow & \underline{\term{id}~(\lam{z}{\term{id}}~z)} \\
	\rightarrow & \lam{z}{\underline{\term{id}~z}} \\
	\rightarrow & \lam{z}{z} \\
	\nrightarrow
	\end{aligned}
	$$
	\item The {\color{red} call by name} strategy is yet more restrictive, allowing no reductions inside abstractions. 
	$$
	\begin{aligned}
	& \underline{\term{id}~(\term{id}~(\lam{z}{\term{id}~z}))} \\
	\rightarrow & \underline{\term{id}~(\lam{z}{\term{id}}~z)} \\
	\rightarrow & \lam{z}{\term{id}~z} \\
	\nrightarrow
	\end{aligned}
	$$
	\item Most languages use a {\color{red} call by value} strategy, in which only outermost redexes are reduced and where a redex is reduced only when its right-hand side has already been reduced to a value-a term that is finished computation and cannot be reduced and further.
	$$
	\begin{aligned}
	& \term{id}~\underline{(\term{id}~(\lam{z}{\term{id}~z}))} \\
	\rightarrow & \underline{\term{id}~(\lam{z}{\term{id}}~z)} \\
	\rightarrow & \lam{z}{\term{id}~z} \\
	\nrightarrow
	\end{aligned}
	$$
\end{enumerate}

{\color{blue} 注意call by name和 call by value的区别，call by name是在$\lambda$函数调用前不对参数进行规约而直接替换到函数body内，换言之如果一个参数不会被用到，那么它永远都不会被evaluated，call by value是其对立情况，先对参数进行规约}.

{\color{red} Evaluation strategies are used by programming languages to determine two things—when to evaluate the arguments of a function call and what kind of value to pass to the function}.
\end{definition}

\newpage
\subsection{Programming in the Lambda-Calculus}

\begin{definition}
\rm {\color{red} 高阶函数} A higher order function is a function that takes a function as an argument, or returns a function.
$$
f^{\circ n} = \underbrace{f \circ f \circ \cdots \circ f}_{n~\text{times}}.
$$
\end{definition}


\begin{annotation}
\rm Define $\circ$ itself as a function:
$$
\circ = \lam{f}{\lam{g}{\lam{x}{f(g(x))}}}. 
$$
So function composition can be denoted by
$$
\circ~f~g  = \lam{x}{f(g(x))}.
$$
\bluet{非常漂亮}. 
\end{annotation}

\begin{annotation}
\rm {\color{red} 多参数柯里化} Motivation is that the lambda-calculus provides no built-in support for multi-argument functions. The solution here is higher-order functions. 

Instead of writing $f = \lam{(x,y)}{\term{s}}$, as we might in a richer programming language, we write $f = \lam{x}{\lam{y}{\term{s}}}$. we then apply $f$ to it arguments one at times, write $f~v~w$, which reduces to
$$
f~v~w \rightarrow \lam{y}{\left[ x \mapsto v \right] s} \rightarrow \left[ x \mapsto v \right]\left[ y \mapsto w \right]s.
$$
This transformation of multi-arguments function into higher-order function is called {\color{red} currying} in honor of Haskell Curry,a contemporary of Church.
\end{annotation}

\begin{annotation}
\rm {\color{red} Church形式的布尔代数} Define the terms \textbf{tru} and \textbf{fls} as follows:
$$
\begin{aligned}
\text{tru} &= \lam{t}{\lam{f}{t}}\\
\text{fls} &= \lam{t}{\lam{f}{f}}\\
\end{aligned}
$$
The terms \textbf{tru} and \textbf{fls} can be viewed as representing the boolean values“true” and “false,” then define a combinator \textbf{test} with the property that $\text{test}~b~v~w$ reduces to $v$ when $b$ is \textbf{tru} and reduces $w$ when $b$ is \textbf{fls}.
$$
\text{test}~= \lam{l}{\lam{m}{\lam{n}{l~m~n}}};
$$  
The \textbf{test} combinator does not actually do much: $test~b~v~w$ reduces to $b~v~w$. i.e., the term $\text{test}~\text{tru}~v~w$ reduces as follows:
$$
\begin{aligned}
&\text{test}~\text{tru}~v~w \\
= & \text{tru}~v~w \\
\rightarrow & \underline{(\lam{t}{\lam{f}{t}})~v}~w \\
\rightarrow & \underline{(\lam{f}{v})~w} \\
\rightarrow & v.
\end{aligned}
$$
We can also define boolean operator like logical conjunction as functions:
$$
\text{and} = \lam{b}{\lam{c}{b~c~\text{fls}}} = \lam{b}{\lam{c}{b~c~b}} 
$$
Define logical \textbf{or} and \textbf{not} as follows:
$$
\begin{aligned}
\text{or} &= \lam{b}{\lam{c}{b~\text{tru}~c}} = \lam{b}{\lam{c}{b~b~c}} \\
\text{not} &= \lam{b}{b~\text{fls}~\text{tru}} \\
\text{xor} &= \lam{b}{\lam{c}{b~(\text{not}~c)~c}}
\end{aligned}
$$ 
\end{annotation}

$$
\begin{aligned}
\text{tru} &= \lam{t}{\lam{f}{t}}\\
\text{xor} &= \lam{a}{\lam{b}{a~(\text{not}~b)~b}} \\
\text{xor}~\text{tru}~b &= \text{tru}~(\text{not}~b)~b \\
						&= \text{not}~b 
\end{aligned}
$$

\begin{annotation}
\rm {\color{red} 有序对} Using booleans, we can encode pairs of values as terms.
$$
\begin{aligned}
\text{pair} &= \lam{f}{\lam{s}{\lam{b}{b~f~s}}} \\
\text{fst} &= \lam{p}{p~\text{tru}} \\
\text{snd} &= \lam{p}{p~\text{fls}} \\
\end{aligned}
$$

{\color{blue} pair变成了一个函数，它可以接收一个tru或者fls来返回第一个值或者第二个值，fst和snd就是pair的一个applying过程，比较有趣}.
\end{annotation}

\begin{annotation}
\rm {\color{red}Church形式的序数} Define the Church numerals as follows
$$
\begin{aligned}
c_0 &=  \lam{s}{\lam{z}{z}} \\
c_1 &=  \lam{s}{\lam{z}{s~z}} \\
c_2 &=  \lam{s}{\lam{z}{s~(s~z)}} \\
c_3 &=  \lam{s}{\lam{z}{s~(s~(s~z))}}  \\
&\cdots
\end{aligned}
$$
这里我们使用高阶函数来描述这一性质
\begin{center}
\begin{tabular}{r |l |l }
 \text{Number} & \text{Function definition} & \text{Lambda expression} \\
\hline
 0 & $0~f~x = x$  & $0 = \lam{f}{\lam{x}{x}}$ \\ 
 1 & $1~f~x = f~x$ & $1 = \lam{f}{\lam{x}{f~x}}$ \\  
 2 & $2~f~x = f~(f~x)$ & $2 = \lam{f}{\lam{x}{f~(f~x)}}$ \\
 3 & $3~f~x = f~(f~(f~x))$ & $3 = \lam{f}{\lam{x}{f~(f~(f~x))}}$ \\
 \vdots & \vdots & \vdots \\
 n & $n~f~x = f^n~x$ & $n = \lam{f}{\lam{x}{f^{\circ n}~x}}$ \\
\end{tabular}
\end{center}

{\color{blue} 参考皮亚诺公理，对应这里我们构建自然数需要有一个$0$和一个后继函数$f$. 你会注意到$c_0$和\textbf{fls}是同一个term，常规编程语言里面很多情况下$0$和false确实也是一个东西}.
\end{annotation}


\begin{annotation}
\rm {\color{red}Church形式序数的运算符} We can define the successor function on Church numerals as follows
$$
\text{succ} = \lam{n}{\lam{s}{\lam{z}{s~(n~s~z)}}}
$$

{\color{blue} 注意这里的后继函数接受对象是一个Church numeral，从而返回新的Church numeral，和我们构造Church number中的后继不是一个东西，它的作用就是让对应具体的数再复合一次$f$. 因此分解一下上面的apply过程，首先是$(n~s~z)$得到相对应的数，然后在对它复合一次$f$}.

另外一种形式
$$
\text{succ} = \lam{n}{\lam{s}{\lam{z}{n~s~(s~z)}}}
$$
{\color{blue} 这个方式也很巧妙，相当于把$0' = 0 + 1$作为新的零元}.
\end{annotation}

\begin{annotation}
\rm The addition of Church numerals can be preformed by a term \textbf{plus} that takes two Church numerals $m$ and $n$, as arguments, and yields another Church numeral. 
$$
\text{plus} = \lam{m}{\lam{n}{\lam{s}{\lam{z}{m~s~(n~s~z)}}}}
$$

{\color{blue} 这里遵循函数复合的结合律$f^{\circ(m+n)}(z) = f^{\circ m}(f^{\circ n}(x))$，相对于把其中的一个Church number对应的具体数当做了另一个Church numeral的zero}.
\end{annotation} 

\begin{annotation} \rm
$$
\text{times} = \lam{m}{\lam{n}{m~(\text{plus}~n)~c_0}}
$$

{\color{blue} 这个就非常有趣了，这里先固定$m$，把它succ设为$\text{plus}~n$和zero设为$c_0$，相当于$(\text{plus}~n)^m(c_0)$}.

另一种更简洁的形式:
$$
\text{times} = \lam{m}{\lam{n}{\lam{s}{\lam{z}{m~(n~s)~z}}}}
$$
{\color{blue} 这里的$(n~s)$变成了一个特殊abstraction $s^{\circ n} = \lam{z}{s(s(\cdots(s~z)\cdots))}$，它并不是一个标准的$\text{succ}$形式}
\end{annotation}

\begin{annotation} \rm 
$$
\text{exp} = \lam{m}{\lam{n}{n~m}}
$$

推一个来看看，注意其中的几次$\alpha$变换，避免产生变量名的冲突.
$$
\begin{aligned}
\text{exp}~c_3~c_2 &= c_2~c_3 \\
			&= (\lam{s}{\lam{z}{s~(s~z)}})~c_3 \\
			&= \lam{z}{c_3~(c_3~z)} \\
	{\color{red}\leadsto_\alpha} &= \lam{z}{(\lam{f}{\lam{x}{f~(f~(f~x))}})~((\lam{f}{\lam{x}{f~(f~(f~x))}})~z)} \\
			&= \lam{z}{(\lam{f}{\lam{x}{f~(f~(f~x))}})~(\lam{x}{z~(z~(z~x))})} \\
	{\color{red}\leadsto_\alpha} &= \lam{z}{(\lam{f}{\lam{x}{f~(f~(f~x))}})~(\lam{g}{z~(z~(z~g))})} \\
			&= \lam{z}{\lam{x}{(\lam{g}{z~(z~(z~g))})~((\lam{g}{z~(z~(z~g))})~((\lam{g}{z~(z~(z~g))})~x))}} \\
			&= \lam{z}{\lam{x}{(\lam{g}{z~(z~(z~g))})~((\lam{g}{z~(z~(z~g))})~(z~z~z~x))}}\\
			&= \lam{z}{\lam{x}{(\lam{g}{z~(z~(z~g))})~(z~z~z~z~z~z~x)}} \\
			&= \lam{z}{\lam{x}{z~z~z~z~z~z~z~z~z~x}} \\
			&= \lam{s}{\lam{z}{s~s~s~s~s~s~s~s~s~z}} \\
			&= c_9 \\	
\end{aligned}
$$
\end{annotation}

\newpage
\section{Simple Types}

\subsection{Typed Arithmetic Expressions}

\begin{definition}
\rm The typing relation for arithmetic expressions, written
$$
\termtype{\term{t}}{\text{T}}
$$
is defined by a set of inference rules assigning types to terms.
$$
\begin{array}{c}
\termtype{\true}{\text{bool}} \\
\termtype{\false}{\text{bool}} \\[0.5em]
\infer{\termtype{\ifelse{\term{t}_1}{\term{t}_2}{\term{t}_3}}{\text{T}}}{\termtype{\term{t}_1}{\text{bool}} & \termtype{\term{t}_2}{\text{T}} & \termtype{\term{t}_3}{\text{T}}} \\
\termtype{\term{0}}{\text{nat}} \\[0.5em]
\infer{\termtype{\succt{\term{t}_1}}{\text{nat}}} {\termtype{\term{t}_1}{\text{nat}}}\\[0.5em]
\infer{\termtype{\pred{\term{t}_1}}{\text{nat}}} {\termtype{\term{t}_1}{\text{nat}}}\\[0.5em]
\infer{\termtype{\iszero{\term{t}_1}}{\text{bool}}} {\termtype{\term{t}_1}{\text{nat}}}\\
\end{array} 
$$
\end{definition}


\begin{annotation}
\rm 注意分支terms中的$\text{T}$表示任意的types即可能包括$\text{bool}$和$\text{nat}$. 理论上两个分支的表达式的type可以不一样，但是这一样以来似乎就不是well-typed, 处理这样的情况需要等到我们学习更多的类型的type之后才能来重新构造. 
\end{annotation}

\begin{definition}
\rm A term $\term{t}$ is \redt{typbale or well typed} if there is some $\text{T}$ such that $\termtype{\term{t}}{\text{T}}$. If $\term{t}$ is typable, then its type is unique(\redt{uniquness of types}). 
\end{definition}

%why
\begin{annotation}
\rm 这里很重要是理解如果给定一个type relation $\termtype{\term{t}}{\text{T}}$，那么肯定是由上述inference rule推导出来的，所以我们会经常看到从conclude推premise的过程，也就是寻找合适的inference rule反向推导，这个过程我们称其为\bluet{derivation}，其中反向寻找合适的inference rule的方法是利用了所谓inversion lemma. 
\end{annotation}

\begin{theorem}
\rm \redt{progress} A well-typed term is not stuck.
\end{theorem}

\begin{proof}
\rm 我们利用structural induction来证一下progress. 首先基本的terms $\false, \true, 0, \succt{\term{nv}}$都是明显的values, 其中$\term{nv}$表示一个numeric value. 

\begin{case}
$\term{t} = \ifelse{\term{t}_1}{\term{t}_2}{\term{t}_3} ~~~~ \term{t}_1 = \text{bool} ~~ \term{t}_2 = \text{T} ~~ \term{t}_3 = \text{T}.$

由归纳假设当$\term{t}_1 = \true$或者$\term{t}_1 = \false$时，我们对$\term{t}$一步evaluation得到$\term{t}_2$或者$\term{t}_3$.  另外当$\term{t}_1 \to \term{t}_1'$时，我们也可以得到$\term{t} \to \ifelse{\term{t}_1'}{\term{t}_2}{\term{t}_3}$. 
\end{case} 

\begin{case}
$\term{t} = \succt{\term{t}_1} ~~~ \term{t}_1 = \text{nat}.$

由归纳假设当$\term{t}_1 = \text{nv}$时，那么$\succt{\term{t}_1}$还是一个numeric value. 另外当$\term{t}_1 \to \term{t}_1'$，我们也可以得到$\term{t} \to \succt{\term{t}_1'}$
\end{case} 

\begin{case}
$\term{t} = \pred{\term{t}_1}~~~ \term{t}_1 = \text{nat}.$

同上.
\end{case} 

\begin{case}
$\term{t} = \iszero{\term{t}_1}~~~ \term{t}_1 = \text{nat}.$

同上.
\end{case}
\end{proof}

\begin{annotation}
\rm 换言之progress保证是任意一个well-typed term，它可能是一个value或者可以进一步根据evaluation rules推导. 
\end{annotation}


\begin{theorem}
\rm \redt{preservation} If a well-typed term takes a step of  evaluation, then the resulting term is also well typed. 
\end{theorem}

\begin{definition}
\rm
$$
\text{safty} = \text{progress} + \text{preservation}.
$$
\end{definition}


\newpage
\subsection{Simply Typed Lambda-Calculus}

\begin{definition}
\rm Define the type of $\lambda$-abstraction(function) as follow
$$
\termtype{\lam{\term{x}}{\term{t}}}{\singletype{T}_1 \to \singletype{T}_2}
$$
it classifies function that expect agrument of type $\singletype{T}_1$ and return result of type $\singletype{T}_2$. The type constructor $\to$ is right-associative. 
\end{definition}


\begin{annotation}
\rm 试想我们应该怎样给一个function赋予一个type呢？ 首先要解决是这个function需要的argument的type是怎样的？ 这里自然地会想到两种方法，一是直接给argument打上annotation，而是从function body推出argument的type. 第一种type annotation通常称为explicitly typed, 第二种则称其为implicitly typed. 我们如果采用第一种方法，假设给定$\termtype{\term{x}}{\singletype{T}_1}$，同时将$\term{t}_2$中的所有出现的$\term{x}$的type都表示为$\singletype{T}_1$得到$\termtype{\term{x}}{\singletype{T}_2}$，那么显然此时就可以构造出一个abstraction和它对应type为$\termtype{\lam{\term{x}}{\term{t}_2}}{\singletype{T}_1 \to \singletype{T}_2}$，形式化的描述这个type rule即为
$$
\infer{\termtype{\lam{\term{x}}{\term{t}_2}}{\singletype{T}_1 \to \singletype{T}_2}}{\termtype{\term{x}}{\singletype{T}_1} \vdash \termtype{\term{t}_2}{\singletype{T}_2}}
$$
其中$\vdash$可以解释为under，即obtain some type relations under some assumptions. 特别地$\vdash \termtype{\term{x}}{\singletype{T}}$表示assumptions是空的. 
\end{annotation}

\begin{definition}
\rm A typing context $\Gamma$ is a sequence of distinct variables and thier types as follow
$$
\Gamma = \termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\termtype{\term{x}_3}{\singletype{T}_3},\cdots
$$
\end{definition}

\begin{annotation}
\rm \redt{rule of typing abstractions} 如果考虑上nested abstraction的情况，我们扩展一下前面提到的type inference
$$
\infer{\Gamma \vdash \termtype{\lam{\term{x}}{\term{t}_2}}{\singletype{T}_1 \to \singletype{T}_2}}{\termtype{\Gamma,\term{x}}{\singletype{T}_1} \vdash \termtype{\term{t}_2}{\singletype{T}_2}}.
$$
这里我们规定$\term{t}_2$中除$\term{x}$外的free variables均在$\Gamma$中.
\end{annotation}

\begin{annotation}
\rm \redt{rule of variables} A variable has whatever type we are currently assuming it to have,
$$
\infer{\Gamma \vdash \termtype{\term{x}}{\singletype{T}}}{\termtype{\term{x}}{\singletype{T}} \in \Gamma}
$$
\end{annotation}


\begin{annotation}
\rm \redt{rule of applications}
$$
\infer{\Gamma \vdash \termtype{\term{t}_1 \term{t}_2}{\singletype{T}_2}}{\Gamma	\vdash \termtype{\term{t}_1}{\singletype{T}_1 \to \singletype{T}_2 } & \Gamma \vdash \termtype{\term{t}_2}{\singletype{T}_2} }
$$
\end{annotation}

\begin{annotation}
\rm \redt{rule of conditionals}  
$$
\infer{\Gamma \vdash \termtype{\ifelse{\term{t}_1}{\term{t}_2}{\term{t}_3}}{\singletype{T}}}{\Gamma \vdash \termtype{\term{t}_1}{\singletype{bool}} & \Gamma \vdash \termtype{\term{t}_2}{\singletype{T}} & \Gamma \vdash \termtype{\term{t}_3}{\singletype{T}}}
$$
\end{annotation}


\begin{annotation}
\rm We often use $\lambda_{\to}$ to refer to the simply typed lambda-calculus. 
\end{annotation}

\begin{theorem}
\rm \redt{uniquness of types} In a given typing context $\Gamma$, a term $\term{t}$ has at most one type. That is, if a term is typable, then it's type is unique. 
\end{theorem}

\begin{lemma}
\rm \redt{canonical forms}
\begin{enumerate}
	\item If $\term{v}$ is a value of type $\singletype{bool}$, then $\term{v}$ is either $\term{true}$ or $\term{false}$;
	\item If $\term{v}$ is a value of type $\singletype{T}_1\to\singletype{T}_2$, then $\term{v} = \lam{\termtype{\term{x}}{\singletype{T}_1}}{\term{t}_2}$.
\end{enumerate}
\end{lemma}

\begin{lemma}
\rm \redt{weakening} If $\Gamma \vdash \termtype{\term{t}}{\singletype{T}}$ and $x \notin \text{dom}(\Gamma)$, then $\Gamma, \termtype{\term{x}}{\singletype{S}} \vdash \termtype{\term{t}}{\singletype{T}}$.
\end{lemma}

\begin{theorem}
\rm \redt{progress} Suppose $\term{t}$ is a closed, well-typed term(that is $\vdash \termtype{\term{t}}{\singletype{T}}$). Then either $\term{t}$ is a value or else there is some $\term{t}'$ with $\term{t} \to \term{t}'$. 
\end{theorem}

\begin{proof}
proved by structural induction.
\end{proof}

\begin{theorem}
\rm \redt{preservation under substitution} If $\Gamma,  \termtype{\term{x}}{\singletype{S}} \vdash \termtype{\term{t}}{\singletype{T}}$ and $\Gamma \to \termtype{\term{s}}{\singletype{S}}$, then $\Gamma \vdash \termtype{[\term{x} \to \term{s}]\term{t}}{\singletype{T}}$.
\end{theorem}

\begin{proof}
\rm 写几步structural induction找找感觉，因为substitution是第一次出现. 这里我们依然对$\term{t}$来进行归纳.  

\begin{case}
若$\term{t} = \term{v}$，其中$\term{v}$为一个variable. 

分两种情况: (1 若$\term{v} = \term{x}$，则$[\term{x} \to \term{s}]\term{t} = [\term{x} \to \term{s}]\term{v} = \term{s}$，而根据命题条件$\Gamma \to \termtype{\term{s}}{\singletype{S}}$，显然成立. (2 其他情况下，则有$[\term{x} \to \term{s}]\term{v} = \term{v}$，即这个substitution没起作用，显然还是成立. 
\end{case}
\end{proof}

\begin{annotation}
\rm 对于一个language有两种特别的刻画形式：
\begin{itemize}
	\item \redt{Curry-style} 首先我们定义terms，再定义关于它们的求值规则(evaluation rules)，来确定terms的语义. 然后我们在定义一个类型系统来拒绝一些不符合我们预期的terms. 因此语义刻画是在类型之前.
	\item \redt{Church-style} 首先我们定义terms，再确定一些well-typed的terms. 然后只给well-typed terms制定求值规则，来确定其语义. 因此类型先于语义. 
\end{itemize}
它们两个最大的不同就是我们在谈论一个term的语义的时候到底是否关系它此时是well-typed. Curry-style通常适用于刻画implicitly typed system，而Curry-style通常用于刻画explicitly typed system. 
\end{annotation}

\section{Type Extensions}

\subsection{Known Types}

\begin{definition}
\rm \redt{base type} Something like bool, nat, float and string, these type are for describing simple and unstructured values and approriate primitive operation for manipulating these values.
\end{definition}

\begin{definition}
\rm \redt{unit type} a constant $\term{unit}$ with unique type $\singletype{Unit}$, the type can be only from this constant.  
\end{definition}

\begin{definition}
\rm The \redt{sequencing} notation $\seq{\term{t}_1}{\term{t}_2}$ has the effect of evaluating $\term{t}_1$，throwing away its trivial result($\term{unit}$), and going on to evaluate $\term{t}_2$. 
\end{definition}

\begin{annotation}
\rm \redt{ first way to formalize sequencing} Add $\seq{\term{t}_1}{\term{t}_2}$ as a new alternative in the syntax of terms, and then add two evaluation rules
$$
\begin{array}{cc}
\infer{\seq{\term{t}_1}{\term{t}_2} \to \seq{\term{t}_1'}{\term{t}_2}}{\term{t}_1 \to \term{t}_1'} \\
\seq{\term{unit}}{\term{t}_2} \to \term{t}_2 
\end{array}
$$
and a typing rule
$$
\infer{\Gamma \vdash \termtype{\seq{\term{t}_1}{\term{t}_2}}{\singletype{T}_2}}{\Gamma \vdash \termtype{\term{t}_1}{\singletype{Unit}} & \Gamma \vdash \termtype{\term{t}_2}{\singletype{T}_2}}
$$
\end{annotation}

\begin{annotation}
\rm \redt{ second way to formalize sequencing} Regard $\seq{\term{t}_1}{\term{t}_2}$ as an abbreviation for the term $(\lam{\termtype{\term{x}}{\singletype{Unit}}}{\term{t}_2})~\term{t}_1$, where $\term{x} \in \text{FV}(\term{t_2})$. 
\end{annotation}

\begin{theorem}
\rm Suppose $\lambda^E$ for the simply typed lambda-calcuclus with the first way of sequencing formalization and $\lambda^I$ for the simply typed lambda-calculus with $\singletype{Unit}$. Let $\func{e}{\lambda^E}{\lambda^I}$ be the elaboration function that translates from the $\lambda^E$ to $\lambda^I$ by replacing every occurrence of $\seq{\term{t}_1}{\term{t}_2}$ with $(\lam{\termtype{\term{x}}{\singletype{Unit}}}{\term{t}_2})~\term{t}_1$, where $\term{x} \in \text{FV}(\term{t_2})$. Then for each $\term{t}$ of $\lambda^E$, we have 
\begin{enumerate}
	\item $\term{t} \to_E \term{t}'$ iff $e(\term{t}) \to _I e(\term{t}')$;
	\item $\Gamma \vdash_E \termtype{\term{t}}{\singletype{T}}$ iff $\Gamma \vdash_I \termtype{e(\term{t})}{\singletype{T}}$. 
\end{enumerate} 
\end{theorem}

\begin{annotation}
\rm 这个sequencing目前来说和我们现代下的语言里面对应的概念还是有差别的. 根据第一个formalization，也就是我们定义里面提到的它是依赖$\term{t}_1$的evaluation result, 我们对一个sequencing能做的就是首先对$\term{t}_1$进行evaluating，只有它的result是一个$\singletype{Uint}$的时候，我们可以尝试丢掉它转而去处理$\term{t}_2$.  显然当$\term{t}_1$不是trivial的时候，$\term{t_2}$永远得不到的evaluating，就停在了某个$\seq{\term{t}_1'}{\term{t}_2}$. 这是就目前而言的我们可以做的事情. 

再关于第二个formalization而言，它是一个很特别的带注解的application，会有一个自然地疑问，如果此时$\term{t}_1$的evaluation result不是$\singletype{Unit}$，怎么让这个application make sense? 是卡在这里，还是怎样？ 显然在前述的corresponding theorem下我更倾向于是卡在这里.
\end{annotation}

\newpage
\subsection{Known Features}

\begin{definition}
\rm \redt{Ascription} is simple feature for ascribe a particular type to a given term. We write "$\term{t}~\text{as}~\singletype{T}$" for the "the term $\term{t}$, to which we ascribe the type $\singletype{T}$".  
\end{definition}

\begin{definition}
\rm \redt{Let Bindings} $\term{let}~ \term{x}=\term{t}_1~\term{in}~\text{t}_2$, 它们的evaluation rule和type rule根lambda abstraction是差不多的，即
$$
\term{let}~ \term{x}=\term{t}_1~\term{in}~\text{t}_2 = (\lam{\termtype{x}{\singletype{T}_1}}{\term{t}_2})~\term{t}_1. 
$$
\end{definition}


\begin{definition}
\rm \redt{Pair} Pairing, written $\term{t}=\left<\term{t}_1,\term{t}_2\right>$ and projection, written $\projone{\term{t}}$ for the $\term{t}_1$ and $\projtwo{\term{t}}$ for the $\term{t}_2$. One new type constructor, $\singletype{T}_1 \times \singletype{T}_2$, called the product of $\singletype{T}_1$ and $\singletype{T}_2$.
\end{definition}

\begin{definition}
\rm \redt{Tuple} is general formalization of Pair.
\end{definition}

\begin{definition}
\rm \redt{Record} Recording, written $\{\term{l}_1 =\term{t}_1, \cdots, \term{l}_n =\term{t}_n\}$ and thier type $\{\termtype{\term{l}_1}{\singletype{T}_1}, \cdots, \termtype{\term{l}_1}{\singletype{T}_1}\}$. 
\end{definition}

\begin{definition}
\rm \redt{pattern matching} Given two kinds of patterns, varible pattern $\term{x}$ and record pattern $\{\term{l}_1 =\term{p}_1, \cdots, \term{l}_n =\term{p}_n\}$(so it can be nested). Plus a match function $\func{match}{P \times V}{\text{Subs} \cup \text{Fail}}$, where $P$ are patterns, $V$ is values, $\text{Subs}$ are substitutions and $\text{Fail}$ means matching fails. The matching rules as follow
$$
\begin{array}{cc}
match(\term{x}, \term{v}) = [\term{x} \to \term{v}] & M-Var \\
\infer{match(\{\term{l}_1 =\term{p}_1, \cdots, \term{p}_n =\term{p}_n\}, \{\term{l}_1 =\term{v}_1, \cdots, \term{l}_n =\term{v}_n\}) = \sigma_1 \circ \cdots \circ \sigma_n}{\text{for each}~i~match(\term{p}_i,\term{v}_i)= \sigma_i}& M-Rcd
\end{array}
$$
The computation rule for pattern matching generalizes the let-binding as follow
$$
\term{let}~ \term{p}=\term{v}~\term{in}~\text{t} = match(\term{p},\term{v})~\term{t}_1. 
$$
\end{definition}

\begin{definition}
\rm A \redt{sum type} is written as $\singletype{T}_1 + \singletype{T}_2$, there are two terms can be desribed this type: 
\begin{enumerate}
	\item Assume $\termtype{\term{t}_1}{\singletype{T}_1}$, then $\termtype{\redt{\inl{\term{t}_1}}}{\singletype{T}_1 + \singletype{T}_2}$;
	\item Assume $\termtype{\term{t}_2}{\singletype{T}_2}$, then $\termtype{\redt{\inr{\term{t}_2}}}{\singletype{T}_1 + \singletype{T}_2}$.
\end{enumerate}
There is a $\term{case}$ construct that allows us to distinguish whether a given value comes from the left or right branch of a sum,
$$
\caseof{a}{\projone{x_1}}{\projone{x_2}}
$$
\end{definition}


\begin{annotation}
\rm 这里存在一个\bluet{类型唯一性}的问题，如果$\termtype{\term{t}_1}{\singletype{T}_1}$，那么对于任意$\singletype{T}_2$，都有$\termtype{\inl{\term{t}_1}}{\singletype{T}_1 + \singletype{T}_2}$, 显然$\inl{\term{t}_1}$的类型就不唯一了. 

这里有三种解决办法
\begin{enumerate}
	\item 留着$\singletype{T}_2$符号化，typechecker继续往后推，如果遇到某个地方$\singletype{T}_2$可能在当前context需要成为某个特定的值;
	\item 给所有可能的$\singletype{T}_2$一个unified representation(ocaml);
	\item 在语法上要求显式地给$\singletype{T}_2$一个type annotation. 
\end{enumerate}
\end{annotation}

\begin{definition}
\rm \redt{variant} is generalization of sum $\left<\term{l}_1:\term{T}_1, \term{l}_2:\term{T}_2\right>$. 
\end{definition}

\begin{definition}
\rm \redt{option} $\left<\term{none}:\term{Unit}, \term{some}:\term{Nat} \right>$. 
\end{definition}

\begin{definition}
\rm \redt{enumeration} An enumerated type (or enumeration) is a variant type in which the field type associated with each label is $\term{Unit}$.
\end{definition}

\begin{definition}
\rm \redt{single-field variant} $\left<\term{l}:\term{T} \right>$.
\end{definition}

\begin{annotation}
\rm single-field variant的主要作用由一个type构造出多个不一样的types但是仅仅是用附加的labels来刻画的，这就可以描述具有相同type但是不同对象.
\end{annotation}

\newpage
\subsection{Normalization}

\begin{theorem}
\rm If $\vdash \term{t}:\singletype{T}$, then $\term{t} \to^* \term{v}$, where $\term{v}$ is a value, or abbreviate $\term{t}\Downarrow$. 
\end{theorem}

\begin{remark}
\rm 上述normalization theorem使用是simply typed lambda calculus. 
\end{remark}

\begin{annotation}
\rm Normalization又名termination，它在描述一个well-typed的term通过evaluation最终可以变成一个value. 这里values包括false，true和lambda abstraction. 自然地，这里考虑使用induction hypothesis来证明，但是处理不了application。对于application我们需要使用reduction rule
$$
\infer{\Gamma \vdash \termtype{\term{t}_1 \term{t}_2}{\singletype{T}_2}}{\Gamma	\vdash \termtype{\term{t}_1}{\singletype{T}_1 \to \singletype{T}_2 } & \Gamma \vdash \termtype{\term{t}_2}{\singletype{T}_2} }
$$
根据假设$\term{t}_1, \term{t}_2$都是normalizable，那么设$\term{t}_1 \to^* \term{t}_1' = \lam{\termtype{x}{\singletype{T}_1}}{\term{t}_3}$(这里用了一下value of function type的canonical form)和$\term{t}_2 \to^* \term{t}_2'$，其中$\term{t}_2'$是normalized. 再来一个$\beta$ reduction，则有
$$
\term{t}_1' \term{t}_2' = [x \to \term{t}_2']\term{t}_3'
$$
这里有两个问题: (1)$\term{t}_3$是一个怎样的形式？(2) substitution干了什么？  
\end{annotation}


\begin{definition}\label{logical predicate of SN}
\rm Suppose the logical predicate for strong normalization as follow
$$
\begin{array}{ll}
\text{SN}_{\singletype{A}}(\term{t}) \iff \vdash \termtype{\term{t}}{\singletype{A}} ~\wedge~ \term{t}\Downarrow,\\
\text{SN}_{\singletype{T}_1 \to \singletype{T}_2}(\term{t}) \iff \vdash \termtype{\term{t}}{\singletype{T}_1 \to \singletype{T}_2} ~\wedge~ \term{t}\Downarrow \wedge ~\forall \term{t_1}.~\text{SN}_{\singletype{T}_1}(\term{t}_1) \Rightarrow \text{SN}_{\singletype{T}_2}(\term{t}~\term{t}_1)
\end{array} 
$$
where $\singletype{A}$ is base type. 
\end{definition}

\begin{annotation}
\rm 观察上述definition是加强了application的conclude(?)，可以通过这两个logical predicate来继续我们的证明，接下来的证明分两步走:
\begin{enumerate}
	\item 首先证明$\vdash \termtype{\term{t}}{\singletype{T}} \Rightarrow \text{SN}_\singletype{T}(\term{t})$，即所有closed well-typed的term都复合上述定义的logical predicate,
	\item 然后$\text{SN}_\singletype{T}(\term{t}) \Rightarrow \term{t}\Downarrow$.
\end{enumerate}
这种手法就是所谓\redt{logical relation}证明方法. 
\end{annotation}

\begin{lemma}\label{logical predicate well-defined}
\rm $\text{SN}_\singletype{T}(\term{t}) \Rightarrow \term{t}\Downarrow$
\end{lemma}

\begin{proof}
根据定义这是显然的. 
\end{proof}

\begin{annotation}
\rm 证明过程的第一步又会拆成两步:
\begin{enumerate}
	\item $\text{SN}_\singletype{T}(\term{t})$将会在$\term{t}$的evalution过程中保持,
	\item 再做根据type derivations的induction，但是于证明abstraction $\term{t}=\lam{\termtype{x}{\singletype{T}_1}}{\term{t}_2}$满足$\text{SN}_{\singletype{T}_1 \to \singletype{T}_2}(\term{t})$的时候，注意这里我们$\text{SN}$对closed term而言的，因此我们这里根据derivation是
	$$
	\infer{\vdash \lam{\termtype{x}{\singletype{T}_1}}{\term{t}_2}}{\termtype{\term{x}}{\singletype{T}_1} \vdash \termtype{\term{t}_2}{\singletype{T}_2}}
	$$
	问题来了这个inference rule的premise不是empty，因此我们没法继续用induction hypothesis来继续我们的证明，这里需要做一个推广(generalization)，即$\Gamma	\vdash \termtype{\term{t}}{\singletype{T}} \Rightarrow \text{SN}_\singletype{T}(\term{t})$. 
\end{enumerate}
\end{annotation}

\begin{lemma}\label{logical predicate preserved under evalutaion}
\rm If $\termtype{\term{t}}{\singletype{T}}$ and $\term{t} \to \term{t}'$, then $\text{SN}_{\singletype{T}}(\term{t}) \iff \text{SN}_{\singletype{T}}(\term{t}')$ 
\end{lemma}

\begin{proof}
首先由$\term{t} \to \term{t}'$，那么有$\term{t}\Downarrow \iff \term{t}'\Downarrow$. 再分情况，若$\singletype{T} = \singletype{A}$，证明就结束了; 若$\singletype{T} = \singletype{T}_1 \to \singletype{T}_2$，由$\term{t}~\term{t}_1 \to \term{t'}~\term{t}_1 $，则$\term{t}~\term{t}_1\Downarrow \iff \term{t}'~\term{t}_1\Downarrow$，又回到第一种情况，证明了function type额外需要的条件. 
\end{proof}

\begin{lemma}\label{logical predicate under substitution}
\rm If $\termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\cdots,\termtype{\term{x}_n}{\singletype{T}_n} \vdash \termtype{\term{t}}{\singletype{T}}$ and $\term{v}_1,\term{v}_1,\cdots,\term{v}_1$ are closed values of $\singletype{T}_1,\singletype{T}_2,\cdots,\singletype{T}_n$ with $\text{SN}_{\singletype{T}_i}(\term{v}_i)$, then $\text{SN}_{\singletype{T}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t})$
\end{lemma}

\begin{proof}
\rm structural induction as follow
\begin{case}
$$
\begin{array}{ll}
\term{t} = \term{x}_i \\
\singletype{T} = \singletype{T}_i
\end{array}
$$ 

显然成立.
\end{case}

\begin{case}
$$
\begin{array}{ll}
\term{t} = \lam{\termtype{\term{x}}{\singletype{S}_1}}{\term{s}_2} \\
\singletype{T}=\singletype{S}_1 \to \singletype{S}_2 \\
\termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\cdots,\termtype{\term{x}_n}{\singletype{T}_n},\termtype{\term{x}}{\singletype{S}_1} \vdash \termtype{\term{s}_2}{\singletype{S}_2}
\end{array}
$$

显然此时$[\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}$已经一个value了，因为$\term{t}$本来就是一个abstraction.	此时需要额外证明applying过程，即给定任意的$\text{SN}_{\singletype{S}_1}(\term{s})$，有$\text{SN}_{\singletype{S}_2}(([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t})~\term{s})$. 根据Lemma\ref{logical predicate well-defined}，我们有$\term{s} \to^* \term{v}$，根据归纳假设即有
$$
\text{SN}_{\singletype{S}_2}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n,\term{x} \to \term{v} ]\term{t})
$$
而
$$
([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t})~\term{s} \to^* [\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n,\term{x} \to \term{v} ]\term{t},
$$
再用一下Lemma\ref{logical predicate preserved under evalutaion}, 即可得到我们想要的. 
\end{case}

\begin{case}
$$
\begin{array}{ll}
\term{t} = \term{t}_1\term{t}_2 \\
\termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\cdots,\termtype{\term{x}_n}{\singletype{T}_n} \vdash \termtype{\term{t}_1}{\singletype{T}_{11} \to \singletype{T}_{12}} \\
\termtype{\term{x}_1}{\singletype{T}_1},\termtype{\term{x}_2}{\singletype{T}_2},\cdots,\termtype{\term{x}_n}{\singletype{T}_n} \vdash \termtype{\term{t}_2}{\singletype{T}_{11}} \\
\singletype{T} = \singletype{T}_{12}
\end{array}
$$

根据归纳假设有$\text{SN}_{\singletype{T}_{11} \to \singletype{T}_{12}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_1)$和$\text{SN}_{\singletype{T}_{11}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_2)$. 再根据$\text{SN}_{\singletype{T}_{11} \to \singletype{T}_{12}}$的definition，有
$$
\begin{array}{ll}
\text{SN}_{\singletype{T}_{12}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_1 [\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_2) \\
= \text{SN}_{\singletype{T}_{12}}([\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]\term{t}_1~\term{t}_2) 
\end{array}
$$
得证.
\end{case}
\end{proof}

\begin{annotation}
\rm Lemma\ref{logical predicate under substitution}中substitution可以记为$\gamma = [\term{x}_1 \to \term{v}_1,\term{x}_2 \to \term{v}_2,\cdots,\term{x}_n \to \term{v}_n]$，也可以直接记为$\gamma \models \Gamma$，理解为"the substitution $\gamma$ statisfies the type environment, $\Gamma$". 
\end{annotation}

\begin{corollary}
\rm $\vdash \termtype{\term{t}}{\singletype{T}} \Rightarrow \text{SN}_\singletype{T}(\term{t})$.
\end{corollary}

\begin{proof}
\rm 直接从Lemma\ref{logical predicate under substitution}可得.
\end{proof}

\end{document}