\documentclass{article}

\usepackage{ctex}
\usepackage{tikz}
\usetikzlibrary{cd}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{proof}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

%\usepackage{unicode-math}

\usepackage{hyperref} %url
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }


\usepackage[textwidth=18cm]{geometry} % 设置页宽=18

\usepackage{blindtext}
\usepackage{bm}
\parindent=0pt
\setlength{\parindent}{2em} 
\usepackage{indentfirst}


\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\color{blue}\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[hang]{\color{red}\Large\bfseries}{}{0em}{}
%\setcounter{secnumdepth}{1} %section 序号

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{exercise}{Exercise}[section]
\newtheorem{annotation}[theorem]{Annotation}

\newcommand\Set[2]{\{\,#1\mid#2\,\}} %集合
\newcommand\SET[2]{\Set{#1}{\text{#2}}} %

\newcommand{\redt}[1]{\textcolor{red}{#1}}
\newcommand{\bluet}[1]{\textcolor{blue}{#1}}
\newcommand{\abracket}[1]{\ensuremath{\left< #1 \right>}}

\newcommand*{\xfunc}[4]{{#2}\colon{#3}{#1}{#4}}
\newcommand*{\func}[3]{\xfunc{\to}{#1}{#2}{#3}}


\newcommand{\inl}[1]{\ensuremath{\text{inl}~#1}}
\newcommand{\inr}[1]{\ensuremath{\text{inr}~#1}}
\newcommand{\fold}[1]{\ensuremath{{fold}_{#1}}}
\newcommand{\unfold}[1]{\ensuremath{{unfold}_{#1}}}
\newcommand{\lam}[2]{\ensuremath{\lambda #1\ldotp #2}} %lamx.y
\newcommand{\pair}[1]{\ensuremath{\left\langle#1\right\rangle}}
\newcommand{\projone}[1]{\ensuremath{#1.1}}
\newcommand{\projtwo}[1]{\ensuremath{#1.2}}
\newcommand{\caseof}[3]{\ensuremath{{\textbf{case}}~#1~{\textbf{of}}~\inl{x_1}\mapsto #2\mid\inr{x_2}\mapsto #3}}
\newcommand{\Lam}[2]{\ensuremath{\Lambda #1\ldotp #2}}
\newcommand{\pack}[3]{\ensuremath{{pack}~\pair{#1,#2}~{as}~#3}}
\newcommand{\unpack}[4]{\ensuremath{{unpack}~#1~{as}~\pair{#2,#3}~{in}~#4}}
\newcommand{\assign}[2]{\ensuremath{#1~\coloneqq~#2}}
\newcommand{\singletype}[1]{\text{#1}}
\newcommand{\termtype}[2]{\ensuremath{#1:#2}}
\newcommand{\type}[3]{\ensuremath{ \left\{#1:#2\relmiddle|#3 \right\}}}
\newcommand{\matgen}[2]{\ensuremath{\mu #1\ldotp#2}} %ux.y
\newcommand{\mat}[0]{\matgen{\alpha}{\tau}} %ua.t
\newcommand{\fatgen}[2]{\ensuremath{\forall #1\ldotp#2}}
\newcommand{\fat}[0]{\fatgen{\alpha}{\tau}}
\newcommand{\eatgen}[2]{\ensuremath{\exists #1\ldotp#2}}
\newcommand{\eat}[0]{\eatgen{\alpha}{\tau}}
\newcommand{\fatgent}[2]{\ensuremath{\trgb{\forall} #1\ldotp#2}}
\newcommand{\fatt}[0]{\fatgent{\alpt}{\tat}}
\newcommand{\eatgent}[2]{\ensuremath{\trgb{\exists} #1\ldotp#2}}
\newcommand{\eatt}[0]{\eatgent{\alpt}{\tat}}

\newcommand{\fail}[0]{\mi{fail}}

\newcommand{\bnfdef}[0]{\ensuremath{\mathrel{::=}}} %::=
\newcommand{\term}[1]{\ensuremath\mathsf{#1}}
\newcommand{\true}{\term{true}}
\newcommand{\false}{\term{false}}
\newcommand{\ifelse}[3]{\ensuremath{\textbf{if}~#1~\textbf{then}~#2~\textbf{else}~#3}}
\newcommand{\newwhiledo}[2]{\ensuremath{\textbf{while}~#1~\textbf{do}~#2}}
\newcommand{\letvar}[2]{\ensuremath{\textbf{letvar}~#1~\textbf{in}~#2}}
\newcommand{\succt}[1]{\term{succ}~#1}
\newcommand{\pred}[1]{\term{pred}~#1}
\newcommand{\iszero}[1]{\term{iszero}~#1}
\newcommand{\seq}[2]{#1;#2}
\newcommand{\subtyp}[2]{#1<:#2}

\newcommand{\dbracket}[1]{\ensuremath{\left\llbracket\,\vcenter{\hbox{$#1$}}\,\right\rrbracket}}

\begin{document}
\title{Type System + Security = ?}
\author{枫聆 (maplegra)}
\maketitle
\tableofcontents
\newpage

\section{Introduction}

\subsection{Type System}

\begin{definition}
\rm A {\color{red} type system} is a tractable syntactic method for proving the absence of certain program behaviors by classlying phrases according to the kinds of value they compute \cite{TAPL}.
\end{definition}

\begin{annotation}
\rm 个人的题外话: type system就是一种非常巧妙工具能帮你抓住那些你可以尽可能抓住的东西，这些东西就是指那些可以用types所刻画的我们感兴趣的properties. 我觉得这是一种艺术，一种难以言于笔下的艺术，凝聚了一代又一代计算理论先驱们的一种智慧“我们还可以做到更好，我们还可以往前再走一点...”，这些东西需要你慢慢地在他们的字里行间去感受. 
\end{annotation}

\begin{annotation}
\rm 在computation里面有两个东西很重要: (1)怎么做encoding? i.e., 给定一些输入我们如何将其转换成我们当且system中可以接受的东西 (2)怎么做computing? i.e., 我们如何将输入转换成其对应的结果. 我们先用简单的untyped lambda calculus来慢慢说明. 
\end{annotation}

\begin{definition}
\rm Let $\Lambda$ be the set of terms in lambda calculus, it is defined by the follow inductive process:
\begin{itemize}
	\item If $x$ is a variable, then $x \in \Lambda$.
	\item If $x$ is a variable and $M \in \Lambda$, then $\lam{x}{M} \in \Lambda$.
	\item If $M, N \in \Lambda$, then $(M N) \in \Lambda$.
\end{itemize}
\end{definition}

\begin{annotation}
\rm 上述关于lambda calculus的定义实际上就是一个encoding，其中$\lam{x}{M}$称其为abstraction. 如果我们从$\Lambda$任意地取一个term $t$出来如何对其对computing呢? 我们将赋予其两个重要的reductions $\beta$和$\eta$，其实分别对应我们常见的application (函数调用)和extensionality (函数等价).
\end{annotation}

\begin{definition}
\rm if a variable $x$ is in such term $\lam{x}{M}$, then we call $x$ is bound, otherwise $x$ is free. 
\end{definition}

\begin{definition}
\rm A term of the form $(\lam{x}{M})~N$ is called redex (reducible expression), and the operation of rewriting a redex according to the above rule is called $\beta$-reduction, written as
\[
	(\lam{x}{M})~N \to [x \mapsto N] M
\]
where $[x \mapsto N]$ is substitution means "replacing all free occurences of $x$ in $M$ by $N$".
\end{definition}

\begin{definition}
\rm Given a term $\lam{x}{M}$ in $\Lambda$, if $x$ is not free in $M$, then we have a $\eta$-reduction as follows:
\[
	\lam{x}{M} \to M
\]  
\end{definition}

\begin{annotation}
\rm 那么现在拿到一个term之后就可以尝试按照上面的规则来做reduction，实际上这里面还缺一个$\alpha$-conversion, 它是用来处理variables重名冲突的. 最后我们也许可以得到另外一个新的term, 但是这个里面隐藏了一个重要细节，就是当一个term里面存在多个地方可以应用上述规则的时候，我们应当如何选择应用顺序呢？ 这里就可以引出两个经典的reduction strategies: \emph{call by name}和\emph{call by value}.
\end{annotation}

\begin{definition}
\rm In \emph{call by name} reduction strategy, the leftmost redex is always reduced first, and allows no reducations inside abstraction.  
\end{definition}

\begin{definition}
\rm In \emph{call by value} reduction strategy, a redex is reduced only when its right hand side has reduced to a \emph{value} (varible and abstraction), and allows no reducation inside abstraction.
\end{definition}

\begin{annotation}
\rm 注意这两个reducation strategies都是不允许在abstraction里面做reduction的，其两者根本差异就是在做application的时候，call by name是agruments接把值替换到abstraction里面，而call by value是先对arguments做reduction. 当我们选择了一个reducation strategy之后，就可以对一个finite term不断地做reduction，最终我们会得到一个已经无法再继续做reduction的term，这个term就称其为\emph{normal form}.
\end{annotation}

\begin{definition}
\rm A term $N$ is in \emph{normal form} is no reduction rule applies to it.
\end{definition}

\begin{annotation}
\rm 我们并不打算在先前的lambda calculus上建立一个完整的language，例如引入用pure function来刻画的bool, natural number和test等. lambda caculus的引入只是为了进一步说明evaluation过程中所需要的\emph{operational sementics}, 例如small step $t_1 \to t_1'$. 下面我们将\emph{call by value}以inference rules巧妙地融入lambda calculus.
\end{annotation}

\begin{definition}
\rm The untyped lambda calculus is defined as follows:
\[
	\begin{gathered}
	\begin{aligned}
	&t \Coloneqq x ~|~ \lam{x}{t} ~|~ t~t \\
	&v \Coloneqq \lam{x}{t}
	\end{aligned} \\[1em]
	\infer[\textsc{E-App1}]{t_1~t_2 \to t_1'~t_2}{t_1 \to t_1'} \\
	\infer[\textsc{E-App2}]{v_1~t_2' \to v_1~t_2'}{t_2 \to t_2'} \\
	\infer[\textsc{E-AppAbs}]{(\lam{x}{t_1})~v_1 \to [x \mapsto v_1] t_1}{}
	\end{gathered}
\]
\end{definition}

\begin{annotation}
\rm 关于对inference rule的理解，对初次接触它的人并不太友好，因为我们直觉总是告诉我们从上往下看. 对于一个inference rule中间横线之上的东西我们称为premises，横线之下我们称其为conclusion，通常premises可以有多个，而conclusion只有一个. 例如对于$\textsc{E-App1}$我们可以读作: $t_1~t_2 \to t_1'~t_2$ if $t_1 \to t_1$, 因此我们通常是从conclusion来考虑premises, 简单地说就是从下往上读, 这一点尤为重要，它是我们用inference rules做derivation的基础. 

我们来简单地解释一下上面定义的untyped lambda calculus的operational sementics: 首先给出了terms和values(只有abstractions)的准确定义，这里只引入了$\beta$-reduction即\textsc{E-AppAbs} rule，并且将\emph{call by value}也融入了进去，这体现在\textsc{E-App1} rule规定要先对leftmost做reduction，直到leftmost变成了才能value，我们才可以继续使用\textsc{E-App2} rule往右做reduction. 后面我们就将用evaluation来代替reduction在如今untyped lambda calculus中的使用.
\end{annotation}

\begin{definition}
\rm A \emph{derivation} in untyped lambda calculas is either an the instance of \textsc{E-AppAbs} or an application of a evalution rule to derivations concluding its premises. 
\end{definition}

\begin{example}
\rm 我们来举一个关于$(\lam{x}{x}~\lam{y}{y})~z \to (\lam{y}{y})~z$例子:
\[
	\infer[\textsc{E-App1}]{(\lam{x}{x}~\lam{y}{y})~z \to (\lam{y}{y})~z}{\infer[\textsc{E-AppAbs}]{\lam{x}{x}~\lam{y}{y} \to \lam{y}{y}}{}}
\] 
再想想我们是否能得到关于$(\lam{x}{x}~\lam{y}{y}) z \to z$的derivation呢?
\[
	\infer[?]{(\lam{x}{x}~\lam{y}{y})~z \to z}{?}
\]
显然这里没有合适的evaluation rule可以apply，这就是前面定义untyped calculus lambda的精髓之处，我们只能做small step. 
\end{example}

\begin{annotation}
\rm 我们现在来思考另外一个问题: 如果给定一个$\lam{x}{x \lam{y}{y}}~z$，其中$x,y,z$均为variables. 我们对其做evaluation会得到:
\[
	\lam{x}{x~\lam{y}{y}} z \to z~\lam{y}{y} 
\]
最后的结果依然是一个normal form，准确地说是一个neutral form，即它最左边并不是一个abstraction. 但这可能并不是我们想要的东西，因为我们通常希望evaluation的结果是一个value. 这就是涉及到我们是否可以在一开始就refuse掉可能会产生一个我们不期望的看到的结果呢? 而不是在evaluation进行到一半的时候，才恍然大悟. 这时候type system将会作为一个最有利的工具来帮助我们完成这个工作. 为了更清晰说明问题，我们还是先给出一个常见的\emph{pure simply typed lambda calculus}，这就是我们常说的STLC的简化版. 我们会直接给出定义，不会再像前面一样慢慢地推出untyped lambda calculus那样，因为整个过程是相似的，清晰的.  
\end{annotation}

\begin{definition}
\rm The pure simply typed lambda-caculus is defined as follows:
\[
	\begin{gathered}
	\begin{aligned}
	&t \Coloneqq x ~|~ \lam{\termtype{x}{\tau}}{t} ~|~ t~t \\
	&v \Coloneqq \lam{\termtype{x}{\tau}}{t} \\[1em]
	&\tau \Coloneqq \tau \to \tau \\
	&\Gamma \Coloneqq \emptyset ~|~ \Gamma, \termtype{x}{\tau}
	\end{aligned} \\[1em]
	\infer[\textsc{E-App1}]{t_1~t_2 \to t_1'~t_2}{t_1 \to t_1'} \\
	\infer[\textsc{E-App2}]{v_1~t_2' \to v_1~t_2'}{t_2 \to t_2'} \\
	\infer[\textsc{E-AppAbs}]{(\lam{\termtype{x}{t}}{t_1})~v_1 \to [x \mapsto v_1] t_1}{} \\[1em]
	\infer[\textsc{T-Var}]{\Gamma \vdash \termtype{x}{\tau}}{\termtype{x}{\tau} \in \Gamma} \\
	\infer[\textsc{T-Abs}]{\Gamma \vdash \termtype{\lam{\termtype{x}{\tau_1}}{t}}{\tau_1 \to \tau_2}}{\Gamma, \termtype{x}{\tau_1} \vdash \termtype{t}{\tau_2}} \\
	\infer[\textsc{T-App}]{\Gamma \vdash \termtype{t_1~t_2}{\tau_2}}{\Gamma \vdash \termtype{t_1}{\tau_1 \to \tau_2} & \Gamma \vdash \termtype{t_2}{\tau_1}}
	\end{gathered}
\]
\end{definition}

\begin{annotation}
\rm 相比于untyped lambda calculus每个term现在是有一个type $\tau$标签了, 特别地，abstraction的type形如$\tau \to \tau$. 我们这里可能与你经常看见的typed lambda calculus不太一样，我们给abstraction的arguments加上了annotations，这样可以省去type inference带来的额外考虑. 其中$\Gamma$表示contexts, i.e., 我们需要某个term里面所有free variables的types才能进一步推导term它具有什么type, 它是可以为empty set的, 题外话$\Gamma$实际上也是可以看做multi-set的，即$\Gamma = \Gamma_1\cup \Gamma_2$. 这里judgement(也可以叫sequent) $\Gamma \vdash t:\tau$表示term $t$在contexts $\Gamma$下具有type $\tau$，中间这个$\vdash$叫turnstile. 如果我们要验证这个judgement是valid，就需要一个关于它的derivation(这里derivation的定义和前面类似)，这里derivation就需要按照我们这里最下面的三个typing rules来得到. 这里我给的解释是比较简单，但是对于初次接触的人来说并没有那么容易，我将配合几个例子帮助你理解. 
\end{annotation}



\begin{example}
\rm 我们可以尝试推一下关于$\termtype{c}{\tau_2}\vdash \termtype{\lam{\termtype{x}{\tau_1}}{c}}{\tau_2}$, 其中$c$表示一个type为$\tau_2$的constant:
\[
	\infer[\textsc{T-Abs}]{\termtype{c}{\tau_2}\vdash \termtype{\lam{\termtype{x}{\tau_1}}{c}}{\tau_2}}{\infer[\textsc{T-Var}]{\termtype{c}{\tau_2},\termtype{x}{\tau_1} \vdash \termtype{c}{\tau_2}}{}}
\]
这里最上面一层derivation其实隐藏了一个关于context permutation的structural rule(if $\Gamma,\termtype{x_1}{\tau_1},\termtype{x_2}{\tau_2} \vdash \vdash \termtype{t}{\tau}$, then $\Gamma,\termtype{x_2}{\tau_2},\termtype{x_1}{\tau_1} \vdash  \termtype{t}{\tau}$)的应用，虽然它看起来还是很自然的，但是我们必须时刻小心这些structural rules，因为有可能你看起来很显然的structural rules，你直接拿来用或者从system中去掉将会得到一个可能与原来并不等价的system.  
\end{example}

\begin{annotation}
\rm 那么我们将如何把typing rules和evaluation联系起来呢？ 那就不得不提到两个非常非常重要的theorems: \emph{progess theorem} and \emph{perservation theorem}. 前者是说如果某个term是well-typed, 那么它是可以继续evaluation或者它本身已经是一个value了. 后者就更进一步了, 同时告诉我们这个term在evaluation的过程中，它将继续保持对应type. 有了这两个theorems，我们就可以在一开始就做refuse (i.e., refuse some terms that are not well-typed)，这也是一开始就说到的type system可以用来抓住我们想要的某些properties. 它们形式化地表示如下.
\end{annotation}

\begin{theorem}
\rm (Progess Theorem) Suppose $t$ is well-typed term (this is $\vdash \termtype{t}{\tau}$), then either $t$ is value or else there is some $t'$ with $t \to t'$. 
\end{theorem}

\begin{theorem}
\rm (Perservation Theorem) If $\Gamma \vdash \termtype{t}{\tau}$ and $t \to t'$, then $\Gamma \vdash \termtype{t'}{\tau}$. 
\end{theorem}

\begin{annotation}
\rm 我并不打算来严格地证明它们，因为会花费很多篇幅，同时你可能还需要证明其他的一些lemma, 例如some structural rules are admissible(i.e., weakening, contraction)和substitution lemma等等. 有兴趣的同学可以自己去研究一下，总体上过程还是非常straightforward的. 但是我还是简要地提一下关于证明这些类似structural proof结论的时候，会经常用到一种structural induction的方法: 首先给出height of derivation (the greatest number of successive application of rules in it, where \textsc{T-Var} have height $0$ in our current case), 然后我们在这个height上做induction. 再者如果涉及到更精细地证明方式，我们还会定义weight of term，然后在它上面做induction，这一类的induction可以在证明cut-elimination的过程中看见. 最后我们简单地来提及一下关于\emph{subtype polymorphism}概念. 
\end{annotation}


\begin{definition}
\rm Let $\tau_1,\tau_2$ be any types in a system, $\tau_1$ is a \emph{subtype} of $\tau_2$ if any term of type $\tau_1$ can safely be used in context where a term of type $\tau_2$ is expected, simply written $\tau_1 <: \tau_2$.
\end{definition}

\begin{example}
\rm 例如我们有这样一个term $t = \{x_1:int, x_2:int\}$ (tuple) 和一个abstraction $f = \lam{z:\{x_1:int\}}{z.1}$, 其中$z.1$表示fetch tuple中的第一个元素，即这就是$x_1$元素. 那么application $f~t$是well-typed的吗？ 显然是的，因为$t$完全可以被当做type $\{x_1:int\}$来用，即$\{x_1:int, x_2:int\} <: \{x_1:int\}$. 前面的思路就是subtyping中最重要的一个想法\emph{subsumption}.
\end{example}

\begin{definition}
\rm The Subsumpting rule defined as:
\[
	\infer[\textsc{T-Sub}]{\Gamma \vdash \termtype{t}{\tau_2}}{\Gamma \vdash \termtype{t}{\tau_1} & \tau_1 <: \tau_2}
\]
\end{definition}

\begin{annotation}
\rm 其中$\tau_1 <: \tau_2$表示一个subtype relation，这是需要我们额外地来定义，前面例子中提到的tuple就是根据它的width来定义的，同理你也可以来定义其他data structures之间的相关内容. subtype relation有几个比较明显的性质例如: reflexivity和transitivity，这都是很容易证明的. 
\
还有一个比较有趣的是关于abstractions之间的subtype relation定义:
\[
	\infer[]{\tau_1 \to \tau_2 <: \tau_1' \to \tau_2'}{\tau_1' <: \tau_1 & \tau_2 <: \tau_2'}
\]
这就是所谓的"the function arguments are contravariant and the function results are covariant".
\end{annotation}

\begin{annotation}
\rm 好了以上就是你在继续往下读所需要的关于type system的预备知识，或许很简单，又或许不太简单，但是我相信它一定会给那些第一次接触到的人打开另一扇窗. 
\end{annotation}

\subsection{Secure Information Flow}

\begin{annotation}
\rm Information flow是指程序执行的过程中信息流动，那么secure information flow就是指信息在流动的过程中遵守一些policies, i.e., 信息我们可以根据sensitivity分为两个部分low和high, 简称$L$和$H$, 我们允许$L$往$H$流动，而不允许$H$往$L$流动, 因为$L$往往是假设是可以被观测的，因此$H$往$L$流动就意味着敏感信息泄露. 同样的思路我们也可以用来描述信息的integrity分为trusted和untrusted吗, 简称为$T$和$U$, 我们允许$T$往$U$流动, 而不允许$U$往$T$流动. 那么一个很自然地问题就是如何model information flow policy? 这也是我们最为感兴趣的地方. 

我们将owners of imformation表示为程序中的variables. 对于任意一个variable $x$, 我们用$\overline{x}$表示其所具有的the set of security classes，其中包含我们前面提到的sensitivity和integrity. 假设$\overline{x} = \{H,U\}$，而$\overline{y} = \{L, T\}$, 在现有policies下我们是允许$y$到$x$的流动, 因为我们分别比较了对应security proporties. 这样的思路已经非常明显地对应了用lattice来分析问题\cite{DL}. 首先我们可以定义一个两个partial order分别包含$L \leq H$和$T \leq U$, 然后再利用前面这两个poset定义一个product partial order:
\[
	(a_1, b_1) \leq (a_2, b_2) \iff a_1 \leq a_2 ~\text{and}~b_1 \leq b_2 
\]
\end{annotation}

\begin{definition}
\rm Information flow policies are defined by a lattice $(SC, \vee, \wedge)$, where $SC$ is a finite set of security classes partially ordered by $\leq$. For any $a,b \in SC$, we define $\vee$ and $\wedge$ as follows
\[
	\begin{gathered}
	b = a \vee b ~\text{if}~  a \leq b \\
	a = a \wedge b ~\text{if}~  a \leq b	
	\end{gathered}
\]
\end{definition}

\begin{definition}
\rm We define the set of security classes $\overline{e}$ for expression $e$ such that 
\[
\overline{e} = \bigvee\limits_{\text{$x$ is free varible in $e$}} \overline{x}
\]
\end{definition}

\begin{definition}
\rm We define the set of security classes $\overline{c}$ for command $c$ as follows:
\[
	\overline{c} = \bigwedge\limits_{\text{$x$ is assigned to in $c$}} \overline{x}
\]
\end{definition}

\begin{definition}
\rm We can give a program certification condition for representing the information flow policy such that
\[
	\overline{e} ~\leq~ \overline{c}.
\]
\end{definition}

\subsection{Noninterference}

\begin{definition}
\rm We say that a command $c$ satisfies noninterference if equivalent initial memories produce equivalent final memories \cite{noninterference}.
\end{definition}

\begin{annotation}
\rm 简而言之就是说一段程序在等价的初始状态下运行，总可以得到等价的结束状态. 其中等价状态和在程序执行过程状态的变化，使我们需要刻画的东西. 在某种程度上它可以作为验证analysis的correctness，因为我们在做analysis时候总是伴随这一些assumptions, 因此我们的验证思路是在一些特定的assumptions下我们总能得到正确结果，而不受其他的因素影响. 
\end{annotation}

\newpage
\section{Type System for Secure Information flow analysis}

\subsection{Operational Semantics}

\begin{definition}
\rm We consider a simply common language described below:
\[
	\begin{gathered}
	\begin{aligned}
	&(phrases) && p \Coloneqq e~|~c \\
	&(expressions) && e \Coloneqq x ~|~ l ~|~ n ~|~ e_1 \oplus e_2 \\
	&(command) && c ::= e_1 \coloneqq e_2 ~|~ c_1;c_2 ~|~ \ifelse{e}{c_1}{c_2} ~|~ \newwhiledo{e}{c} ~| \\
	&&&\quad\quad~ \letvar{x \coloneqq e}{c}
	\end{aligned}
	\end{gathered}
\]
where $x$ ranges over variables, $l$ over locations, and $n$ over integer literals, and $\oplus$ includes binary operators $+,-,=,<$. Integers are the obly values. We use 0 for false and 1 for true, and assume that locations are well ordered \cite{DGC}.
\end{definition}

\begin{definition}
\rm We define the evalution rules for above language as follows:
\[
	\begin{gathered}
	\infer[\textsc{E-Base}]{\mu \vdash n \Rightarrow n}{} \quad\quad \infer[\textsc{E-Contents}]{\mu \vdash l \Rightarrow \mu(l)}{l \in dom(\mu)} \\[0.5em]
	\infer[\textsc{E-Add}]{\mu \vdash e_1 \oplus e_2 \Rightarrow n_1 \oplus n_2}{\mu \vdash e_1 \Rightarrow n_1 & \mu \vdash e_1 \Rightarrow n_2} \\[0.5em]
	\infer[\textsc{E-Update}]{\mu \vdash l \coloneqq e \Rightarrow \mu[l \mapsto n]}{\mu \vdash e \Rightarrow n & l \in dom(\mu)} \quad \infer[\textsc{E-Seq}]{\mu \vdash c_1;c_2 \Rightarrow \mu_2}{\mu \vdash c_1 \Rightarrow \mu_1 & \mu_1 \vdash \mu_2} \\[0.5em]
	\infer[\textsc{E-Branch}_1]{\mu \vdash \ifelse{e}{c_1}{c_2} \Rightarrow \mu_1}{\mu \vdash e \Rightarrow 1 & \mu \vdash c_1 \Rightarrow u_1} \quad\quad \infer[\textsc{E-Branch}_2]{\mu \vdash \ifelse{e}{c_1}{c_2} \Rightarrow \mu_2}{\mu \vdash e \Rightarrow 0 & \mu \vdash c_2 \Rightarrow u_2} \\[0.5em]
	\infer[\textsc{E-Loop}_1]{\mu \vdash \newwhiledo{e}{c} \Rightarrow u}{\mu \vdash e \Rightarrow 0} \quad\quad \infer[\textsc{E-Loop}_2]{\mu \vdash \newwhiledo{e}{c} \Rightarrow u_2}{\mu \vdash e \Rightarrow 1 & \mu \vdash c \Rightarrow \mu_1 & \mu_1 \vdash \newwhiledo{e}{c} \Rightarrow \mu_2}\\[0.5em]
	\infer[\textsc{E-Letvar}]{\mu \vdash \letvar{x \coloneqq e}{c} \Rightarrow \mu_1-l}{\mu \vdash e \Rightarrow n & \text{$l$ is the fresh location not in $dom(\mu)$} & \mu[l \coloneqq n] \vdash [l \mapsto x]c \Rightarrow \mu_1}
	\end{gathered}
\]
where $\func{\mu}{locations}{values}$ is a memeory map, using $\mu \vdash e \Rightarrow n$ for producing value by expression (that is expression has no side-effect) and $\mu \vdash c \Rightarrow \mu_1$ for producing new memeory map by command, $\mu[l \coloneqq n]$ means $\mu(l) = n$ and otherwise $\mu[l \Rightarrow n](l') = \mu(l')$, $\mu-l$ is new meomery map without $l \in dom(\mu)$ and $[l \mapsto x]c$ means that replacing all occurences of $x$ in $c$ with $l$.
\end{definition}

\begin{annotation}
\rm 上述描述的operational semantics是比较清楚的，值得一提是letvar中重新构造了一个fresh location来替换掉了原来的local variable，这样做的好处是省去了构造local variable的环节. 
\end{annotation}

\subsection{Typing Rules}

\begin{definition}
\rm The types of above lanaguge are defined as follows:
\[
	\begin{gathered}
	\begin{aligned}
	&(data types) && \tau \Coloneqq s \\
	&(phrase types) && \rho \Coloneqq \tau ~|~ \tau~var ~|~ \tau~cmd 
	\end{aligned}
	\end{gathered}
\]
where $s$ range over the sef of $SC$ of security classes, which is assumed to be partially ordered by $\leq$. Type $\tau~var$ is the type of a variable and $\tau~cmd$ is the type of a command. 
\end{definition}

\begin{definition}
\rm The typing judgements have the form
\[
	\Gamma, \Delta \vdash p: \rho
\]
where $\Gamma$ is the context of location typing and $\Delta$ is the context of variable typing. The judgement means that phrase $p$ has type $\rho$ under $\Gamma$ for typing free location in $p$ and $\Delta$ for typing free variable in $p$.
\end{definition}

\begin{definition}
\rm The tpying rules of above language are defined as follows:
\[
	\begin{gathered}
	\infer[\textsc{T-Int}]{\Gamma, \Delta \vdash \termtype{n}{\tau}}{} \quad\quad \infer[\textsc{T-Var}]{\Gamma, \Delta \vdash \termtype{x}{\tau~var}}{\termtype{x}{\tau} \in \Delta} \quad\quad \infer[\textsc{T-Loc}]{\Gamma, \Delta \vdash \termtype{l}{\tau~var}}{\termtype{l}{\tau} \in \Gamma} \\[0.5em]
	\infer[\textsc{T-Arith}]{\Gamma, \Delta \vdash \termtype{e_1 \oplus e_2}{\tau}}{\Gamma, \Delta \vdash \termtype{e_1}{\tau} & \Gamma, \Delta \vdash \termtype{e_2}{\tau}} \quad\quad \infer[\textsc{T-RVal}]{\Gamma, \Delta \vdash \termtype{e}{\tau}}{\Gamma, \Delta \vdash \termtype{e}{\tau~var}} \\[0.5em]
	\infer[\textsc{T-Assign}]{\Gamma, \Delta \vdash \termtype{e_1 \coloneqq e_2}{\tau~cmd}}{\Gamma, \Delta \vdash \termtype{e_1}{\tau~var} & \Gamma, \Delta \vdash \termtype{e_2}{\tau}} \quad\quad \infer[\textsc{T-Seq}]{\Gamma, \Delta \vdash \termtype{c_1;c_2}{\tau~cmd}}{\Gamma, \Delta \vdash \termtype{c_1}{\tau~cmd} & \Gamma, \Delta \vdash \termtype{c_2}{\tau}} \\[0.5em]
	\infer[\textsc{T-If}]{\Gamma, \Delta \vdash \termtype{\ifelse{e}{c_1}{c_2}}{\tau~cmd}}{\Gamma, \Delta \vdash \termtype{e}{\tau} & \Gamma, \Delta \vdash \termtype{c_1}{\tau~cmd} & \Gamma, \Delta \vdash \termtype{c_2}{\tau}}  \\[0.5em]
	\infer[\textsc{T-While}]{\Gamma, \Delta \vdash \termtype{\newwhiledo{e}{c}}{\tau~cmd}}{\Gamma, \Delta \vdash \termtype{e}{\tau} & \Gamma, \Delta \vdash \termtype{c}{\tau~cmd}}  \\[0.5em]
	\infer[\textsc{T-Letvar}]{\Gamma, \Delta \vdash \termtype{\letvar{x \coloneqq e}{c}}{\tau~cmd}}{\Gamma, \Delta \vdash \termtype{e}{\tau_1} & \Gamma, \Delta, \termtype{x}{\tau_1} \vdash \termtype{c}{\tau~cmd}} \\[1em]
	\infer[\textsc{T-Base}]{\vdash \tau_1 <: \tau_2}{\tau_1 \leq \tau_2} \\[0.5em]
	\infer[\textsc{T-Cmd}^-]{\vdash \tau_1~cmd <: \tau_2~cmd}{\tau_2 <: \tau_1}\\[0.5em]
	\infer[\textsc{T-Sub}]{\Gamma, \Delta \vdash \termtype{p}{\rho_2}}{\Gamma, \Delta \vdash \termtype{p}{\rho_1} & \rho_1 <: \rho_2}
	\end{gathered}
\]
\end{definition}


\begin{annotation}
\rm 这里我们实际上仅仅是将secure information flow analysis的算法转换称了typing rules，最终构成了一个type system，后面我们将在这个type system下研究一些有趣的性质. 
\end{annotation}

\subsection{Soundness}

\begin{lemma}
\rm (\redt{Structural Subtyping}) If $\vdash \rho_1 <: \rho_2$, then either
\begin{itemize}
	\item if $\rho_1$ is of the form $\tau_1$ and $\rho_2$ is of the form $\tau_2$, then $\tau_1 \leq \tau_2$;
	\item if $\rho_1$ is of the form $\tau_1~var$ and $\rho_2$ is of the form $\tau_2~var$, then $\tau_1 = \tau_2$;
	\item if $\rho_1$ is of the form $\tau_1~cmd$ and $\rho_2~cmd$ is of the form $\tau_2~cmd$, then $\tau_2 \leq \tau_1$;
\end{itemize}
\end{lemma}

\begin{annotation}
\rm 我并不打算证明上面的\emph{structural subtyping lemma}, 因为比较简单但是比较啰嗦，只需要使用subtyping rules即可. 但是它是比较有用的，可以用来帮我们close掉$\rho_1 <: \rho_2$所在branch的proof，后续是可以看见的.
\end{annotation}

\begin{annotation}
\rm 第一个\emph{simple security lemma}严格证明了well-typed expression $\termtype{e}{\tau}$和前面提到的$\overline{e}$是等价的. 
\end{annotation}

\begin{lemma}
\rm (\redt{Simple Security}) If $\Gamma,\Delta \vdash \termtype{e}{\tau}$, then for every location $l$ in $e$ and $\termtype{l}{\tau_1} \in \Gamma$, we have $\tau_1 \leq \tau$. 
\end{lemma}

\begin{proof}
\rm 我们可以根据$e$的structures来讨论，核心还是在height of derivation上做induction. 

\textsc{Base case}: 分别对last rules为\textsc{T-Int}, \textsc{T-Var}和\textsc{T-Loc}，这些结果都是显然的.

\textsc{Induction case}: 若$e = e_1 \oplus e_2$, 并且其last rule为\textsc{T-Assign}:
\[
	\infer[\textsc{T-Arith}]{\Gamma, \Delta \vdash \termtype{e_1 \oplus e_2}{\tau}}{\Gamma, \Delta \vdash \termtype{e_1}{\tau} & \Gamma, \Delta \vdash \termtype{e_2}{\tau}}
\]
对其两个primises使用induction hypothesis得到命题中结论. 同理last rule为\text{T-RVal}也一样证明. 

特别地，我们最后考虑一下last rule为\textsc{T-Sub}的case:
\[
	\infer[\textsc{T-Sub}]{\Gamma, \Delta \vdash \termtype{e}{\tau}}{\Gamma, \Delta \vdash \termtype{e}{\tau_1} & \tau_1 <: \tau}
\]
其right side primise我们可以用\emph{structural subtyping lemma}来close掉， 因此满足$\tau_1 \leq \tau$，然后继续对left side做derivation回到了前面的cases.
\end{proof}

\begin{annotation}
\rm 第二个\emph{confinement lemma}严格证明了well-typed command $\termtype{c}{\tau}$和前面提到的$\overline{c}$是等价的. 
\end{annotation}

\begin{lemma}
\rm (\redt{Confinement}) If $\Gamma,\Delta \vdash \termtype{c}{\tau}$, then for every location $l$ assigned to in $c$ and $\termtype{l}{\tau_1} \in \Gamma$, we have $\tau_1 \geq \tau$.
\end{lemma}

\begin{proof}
\rm 和证明\emph{simple security lemma}做structural induction, 这里只记录一下几个代表性的cases:
\begin{itemize}
	\item 若$c = e_1 \coloneqq e_2$, 若last rule为apply \textsc{T-Assign}:
	\[
		\infer[\textsc{T-Assign}]{\Gamma, \Delta \vdash \termtype{e_1 \coloneqq e_2}{\tau~cmd}}{\Gamma, \Delta \vdash \termtype{e_1}{\tau~var} & \Gamma, \Delta \vdash \termtype{e_2}{\tau}}
	\]
	注意left side primise，只有\textsc{T-Var}可以对其apply, 这意味着当assignment左边被确定之后，它的type是不能被更改，这是一个小细节(从structural typing lemma的第二个case也能看出来)，再对其用一下induction hypothesis即有命题中的结论. 	
	\item 若$c = \ifelse{e}{c_1}{c_1}$, 若last rule为apply \textsc{T-If}:
\[
	\infer[\textsc{T-If}]{\Gamma, \Delta \vdash \termtype{\ifelse{e}{c_1}{c_2}}{\tau~cmd}}{\Gamma, \Delta \vdash \termtype{e}{\tau} & \Gamma, \Delta \vdash \termtype{c_1}{\tau~cmd} & \Gamma, \Delta \vdash \termtype{c_2}{\tau}}
\]
	显然assignment只可能存在于$c_1$或者$c_2$, 再对后面两个primise使用一下induction hypothesis即可得到命题结论.
	\item 若直接apply \textsc{T-Sub}:
	\[
		\infer[\textsc{T-Sub}]{\Gamma, \Delta \vdash \termtype{c}{\tau~cmd}}{\Gamma, \Delta \vdash \termtype{c}{\tau_1~cmd} & \tau_1 <: \tau~cmd}
	\]
	对其中right side primise用一下\emph{structural typing lemma}可以得到$\tau \leq \tau_1$, left side primise又回到了前面的cases. 
\end{itemize}
\end{proof}

\begin{definition}
\rm We write $\mu_1 \approx_\tau \mu_2$ to mean $\mu_1(l) = \mu_2(l)$ that for all $\termtype{l}{\tau_1} \in \Gamma$ such that $\tau_1 \leq \tau$, where $\mu_1$ and $\mu_2$ are memory maps with same domain. 
\end{definition}

\begin{theorem}
\rm \redt{(Type Soundness)} Suppose $\Gamma \vdash c:\rho$, for any evaluation $\mu_1 \vdash c \Rightarrow \mu_1', \mu_2 \vdash c \Rightarrow \mu_2'$ and $\mu_1 \approx_\tau \mu_2$, then $\mu_1' \approx_\tau \mu_2'$. 
\begin{center}
% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAB12BbJgfQEYQAX1LpMufIRQAmclVqMWbTjwEByYaJAZseAkTL959Zq0QdufaZrG7JRWUeoml5lVY1D5MKAHN4RKAAZgBOEFxIZCA4EEj8zopmIADGINQMdABGMAwACuJ6UiAMMEE4NiCh4ZHUMUiyCqbK7HRoaGEAHrycOHRMacVZOfl2+uYhWL4AFuXUUzB0UGyQYKzpWKtsUBBMmSUVVRGI8dGxiADMCU1uLW2d3ey9-elDeQX25iVlA-OLywRrYobJLbXb7ETBMJHBp1C5XVwpAYZbJvUZFL7lLxCIA
\begin{tikzcd}
\mu_1 \arrow[rr, "c"] \arrow[d, "\approx_\tau"', Rightarrow, no head] &  & \mu_1' \arrow[d, "\approx_\tau", Rightarrow, no head,] \\
\mu_2 \arrow[rr, "c"]                                                 &  & \mu_2'                                               
\end{tikzcd}
\end{center}
\end{theorem}

\begin{proof}
\rm 这个证明过程和我们最前面在pure STLC中progress和preservation是非常相似的. 也得先证明一下progress，你才能对$c$做structural induction. progress是显然的，假设progress已经被证明了，我们来证一下这里preservation中的一个case: 若$c = l \coloneqq e$, 并且last evaluation rule为\textsc{E-Update}. 那么
\[
	\infer[\textsc{E-Update}]{\mu_1 \vdash l \coloneqq e \Rightarrow \mu_1[l \mapsto n_1]}{\mu_1 \vdash e \Rightarrow n_1 & l \in dom(\mu_1)} \quad\quad \infer[\textsc{E-Update}]{\mu_2 \vdash l \coloneqq e \Rightarrow \mu_2[l \mapsto n_2]}{\mu_2 \vdash e \Rightarrow n_2 & l \in dom(\mu_2)}
\]
这里有一个不太方便的地方，就是在给$c$选typing rules的时候，总有两种选择:(1 选\textsc{T-Assign} (2 选\textsc{T-Sub}. 在原文章\cite{DGC}里面，作者把我们前面介绍的typing rules精炼了一下，构造出了一个等价的machine-orient typing system. 就是subtyping rule不再单独存在, 而是直接放到了其余的typing rules里面, 例如\textsc{T-Assign}就变成了
\[
	\infer[\textsc{T-Assign*}]{\Gamma, \Delta \vdash \termtype{e_1 \coloneqq e_2}{\tau_1~cmd}}{\Gamma, \Delta \vdash \termtype{e_1}{\tau_2~var} & \Gamma, \Delta \vdash \termtype{e_2}{\tau_2} & \tau_1 \leq \tau_2}
\]
这样我们的选择就变成确定的了. 不过这里不这样做也没有关系，无法就是把\textsc{T-Sub}提出来再证一次就行. 设$\rho = \tau_1~cmd$. 若last typing rule均为\textsc{T-Assign}
\[
	\infer[\textsc{T-Assign}]{\Gamma, \Delta \vdash \termtype{l \coloneqq e}{\tau_1~cmd}}{\Gamma, \Delta \vdash \termtype{l}{\tau_1~var} & \Gamma, \Delta \vdash \termtype{e}{\tau_1}}	
\]
因为命题中我们不考虑$\Delta$, 因此这里assignment的左边只有locations，这里我们需要分两种情况:
\begin{itemize}
	\item $\tau_1 \leq \tau$, 由$\mu_1 \approx_\tau \mu_2$显然有$\mu_1[l \mapsto n_1]\approx_\tau \mu_2[l \mapsto n_2]$. 因为两个memory maps都分别新增了一个type为$\tau_1$的$l$.
	\item $\tau_1 \nleq \tau$, 和上面情况一样，也有$\mu_1[l \mapsto n_1]\approx_\tau \mu_2[l \mapsto n_2]$, 只不过现在两个memory maps都新增了一个不影响命题判断的location $l$，因为我们只care memory map上type"小于" $\tau$的locations.
\end{itemize}  

若last typing rule均为\textsc{T-Sub}, 即
\[
	\infer[\textsc{T-Sub}]{\Gamma, \Delta \vdash \termtype{l \coloneqq e}{\tau_1~cmd}}{\Gamma, \Delta \vdash \termtype{l \coloneqq e}{\tau_2~cmd} & \infer[\textsc{T-Cmd}^-]{\tau_2~cmd <: \tau_1~cmd}{\tau_1 \leq \tau_2}}
\]
依然是分两种情况讨论$\tau_2$和$\tau$的关系. 这里有比较有趣的情况是一个last rule为\textsc{T-Assign}，另一个为\textsc{T-Sub}. 或者两个都last rule都是\textsc{T-Sub},但是上面的$\tau_2$不一样. 这两个情况我们都可以通过$\tau_1$配合subtyping relation transitivity来做.
\end{proof}


\begin{thebibliography}{9}
\bibitem{TAPL}
Benjamin C. Pierce. Types and Programming Languages.

\bibitem{DL}
D. Bell, L. LaPadula, Secure Computer System: Mathematical Foundations and Model.

\bibitem{noninterference}
Andrew Myers. Proving noninterference for a while-language using small-step. operational semantics.

\bibitem{DGC}
Dennis Volpano, Geoffrey Smith, Cynthia Irvine. A sound system for secure flow analysis.
\end{thebibliography}
\end{document}