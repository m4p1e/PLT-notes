\documentclass{article}

\usepackage{ctex}
\usepackage{tikz}
\usetikzlibrary{cd}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{proof}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

%\usepackage{unicode-math}

\usepackage{hyperref} %url
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }


\usepackage[textwidth=18cm]{geometry} % 设置页宽=18

\usepackage{blindtext}
\usepackage{bm}
\parindent=0pt
\setlength{\parindent}{2em} 
\usepackage{indentfirst}


\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\color{blue}\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[hang]{\color{red}\Large\bfseries}{}{0em}{}
%\setcounter{secnumdepth}{1} %section 序号

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{exercise}{Exercise}[section]
\newtheorem{annotation}[theorem]{Annotation}

\newcommand*{\xfunc}[4]{{#2}\colon{#3}{#1}{#4}}
\newcommand*{\func}[3]{\xfunc{\to}{#1}{#2}{#3}}

\newcommand\Set[2]{\{\,#1\mid#2\,\}} %集合
\newcommand\SET[2]{\Set{#1}{\text{#2}}} %

\newcommand{\redt}[1]{\textcolor{red}{#1}}
\newcommand{\bluet}[1]{\textcolor{blue}{#1}}
\newcommand{\abracket}[1]{\ensuremath{\left< #1 \right>}}

\begin{document}
\title{Sparse Analysis and Path Conditions Transformation}
\author{枫聆}
\maketitle
\tableofcontents

\newpage
\section{The Definition of Sparse Analysis}

\begin{definition}
\rm 定义simple language如下
$$
\begin{aligned}
\text{Program}~P & \coloneqq && F+ \\
\text{Function}~F  & \coloneqq &&  f(v_1,v_2,\cdots) = \{S;\} \\
&&& |~f(v_1,v_2,\cdots) = \emptyset \\
\text{Statement}~S & \coloneqq && v_1 = \abracket{v_1} && ::\textbf{identity} \\
&&& |~v_1 = v_2  && ::\textbf{assignment} \\
&&& |~v_1 = v_1 \oplus v_2  && ::\textbf{binary}\\
&&& |~v_1 = ite(v_2,v_3,v_4) && ::\textbf{if-then-else} \\
&&& |~v_1 = f(v_2,v_3,\cdots)  && ::\textbf{call}\\
&&& |~\textbf{return}~ v_1 = v_2  && ::\textbf{return}\\
&&& |~\textbf{if}~(v_1=v_2)\{S_1;\}  && ::\textbf{branching}\\
&&& |~S_1;S_2 && ::\textbf{sequencing}
\end{aligned}
$$
其中$ite(v_2,v_3,v_4)$是一个三元表达式. 每个function都只有一个return statement作为它的唯一exit node; function的开头都对应的identity function对每一个function parameter进行初始化. 
\end{definition}

\begin{annotation}
\rm 为了方便说明，规定后面提到的所有CFG都是以statement为结点，除了branch statement $\textbf{if}~(c)\{S\}$，我们通常将其条件判断作为一个test node $\textbf{test}(c)$，而其body $S$正常展开.    
\end{annotation}

\begin{definition}
\rm 给定program $P$上的两个statements $x,y$和一个branch condition $z$. 若$x$中使用到了$y$中定义的变量，则称$x$ \redt{数据依赖}(data-dependent)于$y$; 若当$z$可达且值为true时$x$会被执行，则称$x$ \redt{控制依赖}(control-dependent)于$z$. 特别地，关于数据依赖可进一步推广至位于statement上的variables之间.
\end{definition}

\begin{annotation}\label{the-def-of-control-dependence}
\rm 控制依赖更加严格的定义应该是这样: 给定CFG上两个不同的结点$x,y$，若满足下述条件\cite{cdg}: 
\begin{itemize}
	\item 在CFG上存在一条从$x$到$y$的nonempty path $p$满足对任意的$v \in p$且$v \neq x$都有$y~\text{pdom}~v$，其中$\text{pdom}$表示postdominate;  
	\item $y~\text{!pdom}~x$. 
\end{itemize}
则称$y$控制依赖于$x$. 简而言之\bluet{存在某个$x$的后继$x.{\text{succ}_i}$使得$y~\text{pdom}~x.{\text{succ}_i}$，但$y~\text{!pdom}~x$}. 

注意往常我们定义dominate tree都是以基本块为单位，这里直接是CFG上的结点，所以你要推广一下:一个基本块上的结点根据顺序线性关系两个相邻的结点构成immediate dominance，再把基本块之间的支配关系放到原来两个基本块的结尾和开始结点.   
\end{annotation}

%说实话还是有点奇怪，我真的想要吐槽一下，为什么不同的地方总是有不同control flow graph的定义，或者重复定义其实本质含义相同的但表达不同的图表示，直接导致这样一个名词出来之后，你不能直接用，硬是要再解释一下，不然就会有歧义，这就是几乎每篇论文都会自己重新定义相关基本名词，咱们就不能统一下观点吗?


\begin{definition}
\rm 给定simple language上的program $P$，定义它的\redt{program dependence graph} $G = (V,E)$如下
\begin{itemize}
	\item 对任意结点$v \in V$，$v$表示$P$上的一个statement或者statement中某个变量. 
	\item $E$包括两种egdes组成
		\begin{itemize}
			\item \redt{data dependence edges}: 对任意两个variables $x,y$，若$y$的定义数据依赖于$x$，则$(x,y) \in E$，所有这样的edges记为$E_d$. 
			\item \redt{control dependence edges}: 对任意statement $x$和branch condition $z$，若$x$控制依赖于$z$，则$(x,z) \in E$，所有这样的edges记为$E_c$. 		
		\end{itemize}		 
\end{itemize}
\end{definition}


\begin{definition}
\rm 给定simple langugae上的program $P$，构造$E_d$规则如下
$$
\begin{array}{cl}
\infer{(v_2,v_1) \in E_d}{&v_1=v_2&} \\[0.5em]
\infer{(v_2,v_1),(v_3,v_1) \in  E_d}{v_1 = v_2 \oplus v_3} \\[0.5em] 
\infer{(v_2,v_1),(v_3,v_1),(v_4,v_1) \in E_d}{&v_1 = ite(v_2,v_3,v_4)&} \\[0.5em] 
\infer{(v_2,u_1),(w_2,w_1),(w_1,v_1) \in E_d}{&v_1 = f(u_1,\cdots) = \{u_1 = \abracket{u_1}; \cdots; \textbf{return}~w_1=w_2\} &} \\[0.5em] 
\infer{(v_2,v_1) \in E_d}{&v_1 = f(v_2,\cdots) ~~ f(u_1,\cdots) = \emptyset&} & \text{\bluet{不是很理解}}\\[0.5em] 
\infer{(v_2,v_1)\in E_d}{&\textbf{if}~(v_1=v_2)\{\cdots\}&}
\end{array}
$$
即对$P$上每一个statements都应用上述规则. 根据算法\ref{control-dependence}构造$E_c$.
\end{definition}

\begin{lemma}
\rm If $y~\text{pdom}~x$ iff there is path $p: x \to^* y$ such that $y~\text{pdom}~v$ for every node $v \in p$. 
\end{lemma}

\begin{annotation}
\rm 算法\ref{control-dependence}用到了一个衍之上面lemma的new lemma: \redt{给定CFG上两个结点$x,y$，若$y~\text{pdom}~x$，则在RCFG上有$y~\text{dom}~x$}. 在此的基础上，我们再可以check一下$x$ successor $z$，如果$y~\text{!dom}~z$，那么$y$ is control dependent on $z$. 根据dominance frontier的定义，实际上$z$就在$DF(y)$里面.
\end{annotation}

\begin{algorithm}
\label{control-dependence}
\caption{Control Depenence}
%\SetKwFunction{ForwardTabulateSLRPs}{ForwardTabulateSLRPs}
%\SetKwFunction{Propagate}{Propagate}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\DontPrintSemicolon
\Input{The reverse control flow graph $\text{RCFG}$ and the dominance frontier $\text{RDF}$ of every every node in $\text{RCFG}$.} 
\Output{The set $\text{CD}(X)$ of nodes that are control dependent on $X$.}

\Begin{
	\For{\rm each node $X \in \text{RCFG}$}{
		$\text{CD}(X) = \emptyset$	
	}

	\For{\rm each node $X \in \text{RCFG}$ }{
		\For{\rm each node $Y \in \text{RDF}(X)$}{
			Insert $X$ into $\text{CD}(Y)$ \;
		}
	}
}

\end{algorithm}

\newpage
\begin{definition}
\rm 给定program $P$的某个procedure对应CFG上的一条control flow path  $p = (s_0, s_1,\cdots, s_n)$，设$P$的program dependence graph为$G = (V,E)$. 设关注的data facts 为$D$，$s_i$上data values along $p$为$\text{in}_{s_i},\text{out}_{s_i} \subseteq D$，其中除了$\text{in}_{s_0} = I \subseteq D$其它data values都为$\emptyset$，$s_i$的transfer function为$\text{tr}_{s_i}$. 那么$\forall s_i \in p, i=0,1,\cdots,n,$
$$
\begin{aligned}
&\text{out}_{s_i} = \text{tr}_{s_i}(\text{in}_{s_i}) \\
&\text{and}~\forall (s_i,s_j) \in E_d,  \text{in}_{s_j} = \text{in}_{s_j} \cup \text{out}_{s_i}. 
\end{aligned}
$$
上述分析手法称为\redt{sparse analysis}. 同时设对任意$(s_i,s_j)\in E_d$的data dependence edge condition为$\phi(s_i,s_j)$，两个data values表示$\text{in}_{s_i},\text{out}_{s_i} \subseteq D \times \mathcal{P}$，其中$\mathcal{P}$为data dependence paths. 初始化$\text{in}_{s_0} = (I,\prod_{s_0} = \{\})$和$\text{in}_{s_i} = (\emptyset,\prod_{s_i}=\{\}),i=1,2,\cdots,n$，其中$\phi(s_i,s_i)$表示对应statement或者变量本身的约束条件. 那么$\forall s_i \in p, i=0,1,\cdots,n,$
$$
%\bigcup\limits_{p_{i} = (\pi_i,\phi_{\pi_i}) \in \prod_{s_i}}\left\{\abracket{\pi_i,\phi_{\pi_i} \wedge \phi_{(i,i)}}\right\}
\begin{aligned}
&\text{out}_{s_i} = \left(\text{tr}_{s_i}\left(X_{\text{in}_{s_i}}\right),{\prod}_{s_i}\right) \\
&\text{and}~\forall (s_i,s_j) \in E_d,  \text{in}_{s_j} = \text{in}_{s_j} \cup_p \text{out}_{s_i}.
\end{aligned}
$$
其中$\cup_p$定义为
$$
\text{in}_{s_j} \cup_p \text{out}_{s_i} =  \left( X_{\text{in}_{s_j}} \cup X_{\text{out}_{s_i}},  {\prod}_{s_j} \cup {\prod}_{s_i \to s_j}\right), 
$$
其中${\prod}_{s_i \to s_j}$为
$$
\left\{
\begin{aligned}
& \bigcup_{p_i = \abracket{\pi_i=(\cdots,s_i),\phi_{\pi_i}} \in \prod_{s_i}} \left\{\abracket{\pi_i'=(\cdots,s_i,s_j), \phi_{\pi_{i}} \wedge \phi_{(s_i,s_j)}}\right\} & \text{if}~{\prod}_{s_j} \neq \emptyset \\
&\{(s_i,s_j), \phi_{(s_i,s_j)}\} &  \text{if}~{\prod}_{s_j} = \emptyset
\end{aligned}
\right.
$$
则称上述手法为\redt{path-sensitive sparse analysis}. 若将control flow path $p=(s_0,s_1,\cdots,s_n)$推广至interprocedural control flow path，则称其为\redt{interprocedural sparse analysis}. 
\end{definition}


%LOL
\begin{annotation}
\rm sparse analysis相比于"dense" analysis或者conventional analysis，它并不是沿着原本的control flow来传递data facts，而是沿着data dependence来传递的. 自然地就形成了data dependence path，我们若要考虑path-sensitive就直接考虑data dependence path condition.  我这里关于path-sensitive sparse analysis的定义和原文有一点区别，原文一个$\prod$保存了所有data dependence paths，似乎最后把它们聚合到一起来作为整体data dependence path conditions，对此我有点不理解. 因此我把关系每个结点的data dependence paths分开放置，这样后面对某一点进一步分析的时候，我们可以只关注相关的data dependece path和对应的path condition. 


更一步思考我们用sparse analysis想问题思路应该是这样的: 首先忽略路径条件按照data dependence某个特定的程序点是否有我们感兴趣的值，在这过程中踏出了一些data dependence paths，然后我们考虑这些路径上的路径条件是否satisfiable. 更形式化一点就是我们有一些初始化data values $X$，然后我们经过data dependence的分析它可以到达我们期望的程序，然后其传播路径对应的path condition为$\bigwedge \phi_\pi$，因此我们需要求解
\begin{equation}\label{big-equation}
X \wedge \bigwedge \phi_\pi
\end{equation}
是否是satisfiable?
\end{annotation}

\begin{definition}
\rm 定义function summary为$(\pi, \text{tr}_\pi,\phi_\pi)$，其中$\pi=(s_0,s_1,\cdots,s_n)$是function上一条data dependence path，$\text{tr}_\pi = \text{tr}_{s_n} \circ \text{tr}_{s_{n-1}} \circ \cdots \circ \text{tr}_{s_1} \circ \text{tr}_{s_0}$，$\phi_\pi$表示$\pi$对应的path condition. 若$s_n$是\textbf{return} statement则此时function summary可以直接记为$\phi_{\text{ret}}$. 
\end{definition}

\begin{annotation}
\rm 我们通过cache得到的function summary来对interprocedural sensitive sparse analysis做出优化，即在call已经被分析过的function的时候我们可以直接用对应的function summary，按照对应的$\pi$来寻找已经构造的path condition，而不需要重新构造path condition(可能已经简化过path condition).

我一直在想什么时候可以直接复用path condition的求解结果，似乎只有equation \ref{big-equation}中$X$相同时可以复用，对应相同的函数参数配合相同function summary就可以做到复用. 
\end{annotation}

\newpage
\section{Path Conditions Transformation}

\begin{definition}
\rm 给定program $P$的program graph dependence graph $G=(V,E)$和一个包含data dependence paths的集合$\prod$. 定义$\prod$对应的slice为$G^{\prod} = (V^{\prod},E^{\prod})$，构造$G^{\prod}$的规则依次如下:
$$
\begin{array}{cl}
\infer{(u,v_1) \in X_d~\text{where}~u \in \{v_3,v_4\}-\{v_i\}}{\pi \in \prod & (v_i,v_1=ite(v_2,v_3,v_4)) \sqsubset \pi & v_i \in \{v_3,v_4\}} & (1) \\[0.5em]
\infer{v_1,v_2,\cdots,v_n \in V^{\prod}, {\color{red}(\_,v_i)},(v_1,v_2),\cdots,(v_{n-1},v_n) \in E_c^{\prod}}{\pi \in \prod & v \in \pi & (v,v_1),(v_1,v_2),\cdots,(v_{n-1},v_n) \in E_c} & (2) \\[0.5em]
\infer{u \in V^{\prod}, (u,v) \in E_d^{\prod}}{v \in V^{\prod} & (u,v) \in E_d^{\prod}-X_d} & (3)
\end{array}
$$
\end{definition}

\begin{annotation}
\rm slice构造的说明
\begin{itemize}
	\item 整体思路是先构造$\pi$的control dependence graph，在根据control dependence graph上结点把对应的data dependence放进去. 
	\item 规则(1) 用于prune掉$\pi$上$\text{ite}$中未选择的branch  dependence，避免后续在构造control dependence graph上结点的data dependence时出现逻辑错误.
	\item 规则(2) 标红的control dependence表示将其扔掉$E_c$里面的时候，不包括$v$. 整个slice只专注$\pi$上path condition，而$v_1$到$v$依然存在$\phi(v_1,v)$，因此我们可以用一个仅表位置结点$\_$来特殊表示$v$.  
\end{itemize}
\end{annotation}


\begin{definition}
\rm 给定program $P$的program graph dependence graph $G=(V,E)$和一个包含data dependence paths的集合$\prod$及$\prod$对应的slice $G^{\prod} = (V^{\prod},E^{\prod})$. 定义$G^{\prod}$表示的path condition为$\phi_{\prod}$，其构造规则如下
$$
\begin{array}{cl}
\infer{\phi_{\prod}=true}{&&&&} & (4)\\[0.5em]
\infer{\phi_{\prod}=\phi_{\prod}\wedge \llbracket v \rrbracket_c \equiv true}{(u,v) \in E_c^{\prod}} & (5) \\[0.5em] 
\infer{\phi_{\prod}=\phi_{\prod}\wedge \llbracket v \rrbracket_d}{v \in V^{\prod}} & (6) \\[0.5em]
\infer{\phi_{\prod}=\phi_{\prod}\wedge v_1 \equiv v_2}{(v_1,v_2) \in E_d^{\prod} & f(v_1,\cdots) = \{v_2 = \abracket{v_2}; \cdots;\}} & (7) \\[0.5em]
\infer{\phi_{\prod}=\phi_{\prod}\wedge v_1 \equiv v_2}{(v_1,v_2) \in E_d^{\prod} & v_2 = f(\cdots) & f(\cdots) = \{\cdots;\textbf{return}~v_1\}}  & (8) \\[0.5em]
\end{array}
$$
其中$\llbracket v \rrbracket_c$表示$v$对应的$\textbf{if}$ statements中condition，$\llbracket v \rrbracket_d$定义如下
$$
\begin{array}{rl}
\llbracket v_1 = v_2 \rrbracket_d &= v_1 \equiv v_2 \\
\llbracket v_1 = v_2 \oplus v_3 \rrbracket_d &= v_1 \equiv v_2 \oplus v_3\\
\llbracket v_1 = ite(v_2,v_3,v_4) \rrbracket_d & = \left\{\begin{aligned}
&v_2 \equiv true \wedge v_1 \equiv v_3 && \text{if}~(v_3,v_1) \in E_d^{\prod} \wedge (v_4,v_1) \notin E_d^{\prod} \\
&v_1 \equiv false \wedge v_1 \equiv v_4 && \text{if}~(v_3,v_1) \notin E_d^{\prod} \wedge (v_4,v_1) \in E_d^{\prod} \\
&v_1 \equiv \text{ite}(v_2,v_3,v_4) && \text{otherwise} \\
\end{aligned}\right. \\
\llbracket \textbf{return}~v_1 = v_2 \rrbracket_d &= v_1 \equiv v_2 \\
\llbracket \textbf{if}~(v_1 = v_2)\{S_1;\} \rrbracket_d &= v_1 \equiv v_2 \\
\llbracket \text{other} \rrbracket_d &= true
\end{array}
$$
\end{definition}

\begin{theorem}
\rm 
$$
\bigwedge_{\pi \in {\prod}} \phi_\pi= \phi_{\prod}.
$$
\end{theorem}

\begin{annotation}
\rm 显然这里的slice上是没有$\pi$上的结点的，如果$\pi$上有一个statement是$z = x/y$，那么$y$要求不能等于$0$. 因此statement能否正确的执行也需要一定的约束条件，这个不算在path condition里面吗？ 感觉也可以在dataflow分析的transfer function可以处理这个问题，但是$y$的取值确实影响到了运行路径. 
\end{annotation}

\begin{annotation}
\rm 本文其实在着重解决两个问题:
\begin{itemize}
	\item 海量path conditions的cache问题;
	\item context-sensitive interprocedural anlysis下函数调用造成的path conditions clone问题;
\end{itemize}
有了前面基于program dependence graph到path condition的转换规则，可以实现path conditions动态生成，但这有什么用呢？ 我的理解是
\begin{itemize}
	\item 在前述path-sensitive sparse analysis里面我们不需要再计算$\phi_\pi$，同时function summary里面也不需要在存储path condition(data dependence path依然存在).  
	\item 由于slice依然是一张dependence graph，我们可以通过一些分析来这张图来做优化，间接地优化了其对应的path condition.  
\end{itemize}
同时文中也提到了一些关于sat-solver的优化，但是细节不可见，这里也就到此为止了. 应用上述技术构造analyser Fusion对比Pinpoint从evaluation里面来看效果还是比较明显的.
\end{annotation}


\begin{thebibliography}{9}
\bibitem{fusion}
Qingkai Shi, Peisen Yao, Rongxin Wu, Charles Zhang. Path-Sensitive Sparse Analysis without Path Conditions.

\bibitem{cdg}
Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. Efficiently Computing Static Single Assignment Form and the Control Dependence Graph
\end{thebibliography}


\end{document}
