\documentclass{article}

\usepackage{ctex}
\usepackage{tikz}
\usetikzlibrary{cd}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{proof}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

%\usepackage{unicode-math}

\usepackage{hyperref} %url
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }


\usepackage[textwidth=18cm]{geometry} % 设置页宽=18

\usepackage{blindtext}
\usepackage{bm}
\parindent=0pt
\setlength{\parindent}{2em} 
\usepackage{indentfirst}


\usepackage{xcolor}
\usepackage{titlesec}
\titleformat{\section}[block]{\color{blue}\Large\bfseries\filcenter}{}{1em}{}
\titleformat{\subsection}[hang]{\color{red}\Large\bfseries}{}{0em}{}
%\setcounter{secnumdepth}{1} %section 序号

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{exercise}{Exercise}[section]
\newtheorem{annotation}[theorem]{Annotation}

\newcommand*{\xfunc}[4]{{#2}\colon{#3}{#1}{#4}}
\newcommand*{\func}[3]{\xfunc{\to}{#1}{#2}{#3}}

\newcommand\Set[2]{\{\,#1\mid#2\,\}} %集合
\newcommand\SET[2]{\Set{#1}{\text{#2}}} %

\newcommand{\redt}[1]{\textcolor{red}{#1}}
\newcommand{\bluet}[1]{\textcolor{blue}{#1}}
\newcommand{\abracket}[1]{\ensuremath{\left< #1 \right>}}

\begin{document}
\title{Sparse Analysis and Path Conditions Transform}
\author{枫聆}
\maketitle
\tableofcontents

\newpage
\section{The Definition of Sparse Analysis}

\begin{definition}
\rm 定义simple language如下
$$
\begin{aligned}
\text{Program}~P & \coloneqq && F+ \\
\text{Function}~F  & \coloneqq &&  f(v_1,v_2,\cdots) = \{S;\} \\
&&& |~f(v_1,v_2,\cdots) = \emptyset \\
\text{Statement}~S & \coloneqq && v_1 = \abracket{v_1} && ::\textbf{identity} \\
&&& |~v_1 = v_2  && ::\textbf{assignment} \\
&&& |~v_1 = v_1 \oplus v_2  && ::\textbf{binary}\\
&&& |~v_1 = ite(v_2,v_3,v_4) && ::\textbf{if-then-else} \\
&&& |~v_1 = f(v_2,v_3,\cdots)  && ::\textbf{call}\\
&&& |~\textbf{return}~ v_1 = v_2  && ::\textbf{return}\\
&&& |~\textbf{if}~(v_1=v_2)\{S_1;\}  && ::\textbf{branching}\\
&&& |~S_1;S_2 && ::\textbf{sequencing}
\end{aligned}
$$
其中$ite(v_2,v_3,v_4)$是一个三元表达式. 每个function都只有一个return statement作为它的唯一exit node; function的开头都对应的identity function对每一个function parameter进行初始化. 
\end{definition}

\begin{annotation}
\rm 为了方便说明，规定后面提到的所有CFG都是以statement为结点，除了branch statement $\textbf{if}~(c)\{S\}$，我们通常将其条件判断作为一个test node $\textbf{test}(c)$，而其body $S$正常展开.    
\end{annotation}

\begin{definition}
\rm 给定program $P$上的两个statements $x,y$和一个branch condition $z$. 若$x$中使用到了$y$中定义的变量，则称$x$ \redt{数据依赖}(data-dependent)于$y$; 若当$z$可达且值为true时$x$会被执行，则称$x$ \redt{控制依赖}(control-dependent)于$z$. 特别地，关于数据依赖可进一步推广至位于statement上的variables之间.
\end{definition}

\begin{annotation}\label{the-def-of-control-dependence}
\rm 控制依赖更加严格的定义应该是这样: 给定CFG上两个不同的结点$x,y$，若满足下述条件: 
\begin{itemize}
	\item 在CFG存在一条从$x$到$y$的nonempty path $p$满足对任意的$v \in p$且$v \neq x$都有$y~\text{!pdom}~v$，其中$\text{pdom}$表示postdominate;  
	\item $y~\text{!pdom}~x$. 
\end{itemize}
则称$y$控制依赖于$x$. 简而言之\bluet{存在某个$x$的后继$x.{\text{succ}_i}$使得$y~\text{pdom}~x.{\text{succ}_i}$，但$y~\text{!pdom}~x$}. 

注意往常我们定义dominate tree都是以基本块为单位，这里直接是CFG上的结点，所以你要推广一下:一个基本块上的结点根据顺序线性关系两个相邻的结点构成immediate dominance，再把基本块之间的支配关系放到原来两个基本块的结尾和开始结点.   
\end{annotation}

%说实话还是有点奇怪，我真的想要吐槽一下，为什么不同的地方总是有不同control flow graph的定义，或者重复定义其实本质含义相同的但表达不同的图表示，直接导致这样一个名词出来之后，你不能直接用，硬是要再解释一下，不然就会有歧义，这就是几乎每篇论文都会自己重新定义相关基本名词，咱们就不能统一下观点吗?


\begin{definition}
\rm 给定simple language上的program $P$，定义它的\redt{program dependence graph} $G = (V,E)$如下
\begin{itemize}
	\item 对任意结点$v \in V$，$v$表示$P$上的一个statement或者statement中某个变量. 
	\item $E$包括两种egdes组成
		\begin{itemize}
			\item \redt{data dependence edges}: 对任意两个variables $x,y$，若$y$的定义数据依赖于$x$，则$(x,y) \in E$，所有这样的edges记为$E_d$. 
			\item \redt{control dependence edges}: 对任意statement $x$和branch condition $z$，若$x$控制依赖于$z$，则$(x,z) \in E$，所有这样的edges记为$E_c$. 		
		\end{itemize}		 
\end{itemize}
\end{definition}


\begin{definition}
\rm 给定simple langugae上的program $P$，构造$E_d$规则如下
$$
\begin{aligned}
&\infer{(v_2,v_1) \in E_d}{&v_1=v_2&} \\[0.5em]
&\infer{(v_2,v_1),(v_3,v_1) \in  E_d}{v_1 = v_2 \oplus v_3} \\[0.5em] 
&\infer{(v_2,v_1),(v_3,v_1),(v_4,v_1) \in E_d}{&v_1 = ite(v_2,v_3,v_4)&} \\[0.5em] 
&\infer{(v_2,u_1),(w_2,w_1),(w_1,v_1) \in E_d}{&v_1 = f(u_1,\cdots) = \{u_1 = \abracket{u_1}; \cdots; \textbf{return}~w_1=w_2\} &} \\[0.5em] 
&\infer{(v_2,v_1) \in E_d}{&v_1 = f(v_2,\cdots) ~~ f(u_1,\cdots) = \emptyset&} & \text{\bluet{不是很理解}}\\[0.5em] 
&\infer{(v_2,v_1)\in E_d}{&\textbf{if}~(v_1=v_2)\{\cdots\}&}
\end{aligned}
$$
即对$P$上每一个statements都应用上述规则. 根据算法\ref{control-dependence}构造$E_c$.
\end{definition}

\begin{annotation}
\rm 算法\ref{control-dependence}用到了一个lemma: \redt{给定CFG上两个结点$x,y$，若$y~\text{pdom}~x$，则在RCFG上有$y~\text{dom}~x$}. 
\end{annotation}

\begin{algorithm}
\label{control-dependence}
\caption{Control Depenence}
%\SetKwFunction{ForwardTabulateSLRPs}{ForwardTabulateSLRPs}
%\SetKwFunction{Propagate}{Propagate}
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\DontPrintSemicolon
\Input{The reverse control flow graph $\text{RCFG}$ and the dominance frontier $\text{RDF}$ of every every node in $\text{RCFG}$.} 
\Output{The set $\text{CD}(X)$ of every node $X$ that are control dependent on $X$.}

\Begin{
	\For{\rm each node $X \in \text{RCFG}$}{
		$\text{CD}(X) = \emptyset$	
	}

	\For{\rm each node $X \in \text{RCFG}$ }{
		\For{\rm each node $Y \in \text{RCFG}$}{
			Insert $Y$ into $\text{CD}(X)$ \;
		}
	}
}

\end{algorithm}

\newpage
\begin{definition}
\rm 给定program $P$的某个procedure对应CFG上的一条control flow path  $p = (s_0, s_1,\cdots, s_n)$，设$P$的program dependence graph为$G = (V,E)$. 设关注的data facts 为$D$，$s_i$上data values along $p$为$\text{in}_{s_i},\text{out}_{s_i} \subseteq D$，其中除了$\text{in}_{s_0} = I \subseteq D$其它data values都为$\emptyset$，$s_i$的transfer function为$\text{tr}_{s_i}$. 那么$\forall s_i \in p, i=0,1,\cdots,n,$
$$
\begin{aligned}
&\text{out}_{s_i} = \text{tr}_{s_i}(\text{in}_{s_i}) \\
&\text{and}~\forall (s_i,s_j) \in E_d,  \text{in}_{s_j} = \text{in}_{s_j} \cup \text{out}_{s_i}. 
\end{aligned}
$$
上述分析手法称为\redt{sparse analysis}. 同时设对任意$(s_i,s_j)\in E_d$的data dependence edge condition为$\phi(s_i,s_j)$，$\text{in}_{s_i},\text{out}_{s_i} \subseteq D \times \mathcal{P}$，其中$\mathcal{P}$为data dependence paths. 初始化$\text{in}_{s_0} = (I,\prod_{s_0} = \{\abracket{(s_0),\phi_{(s_0)}}\})$和$\text{in}_{s_i} = (\emptyset,\prod_{s_i}=\{\}),i=1,2,\cdots,n$，其中$\phi(s_i,s_i)$表示对应statement或者变量本身的约束条件. 那么$\forall s_i \in p, i=0,1,\cdots,n,$
$$
\begin{aligned}
&\text{out}_{s_i} = \left(\text{tr}_{s_i}(X_{s_i}),\bigcup\limits_{p_{i} = (\pi_i,\phi_{\pi_i}) \in \prod_{s_i}}\left\{\abracket{\pi_i,\phi_{\pi_i} \wedge \phi_{(i,i)}}\right\}\right) \\
&\text{and}~\forall (s_i,s_j) \in E_d,  \text{in}_{s_j} = \text{in}_{s_j} \cup_p \text{out}_{s_i}.
\end{aligned}
$$
其中$\cup_p$定义为
$$
\text{in}_{s_j} \cup_p \text{out}_{s_i} = \left(X_{\text{in}_{s_j}} \cup X_{\text{out}_{s_i}},  \prod_{s_j} \cup \bigcup\limits_{p_i = \abracket{\pi_i=(\cdots,s_i),\phi_{\pi_i}} \in \prod_{i}} \left\{\abracket{\pi_i'=(\cdots,s_i,s_j)}, \phi_{\pi_{i}'}\right\}\right). 
$$
则称上述手法为\redt{path-sensitive sparse analysis}. 
\end{definition}

%LOL
\begin{annotation}
\rm sparse analysis相比于"dense" analysis或者conventional analysis，它并不是沿着原本的control flow来传递data facts，而是沿着data dependence来传递的. 自然地就形成了data dependence path，我们若要考虑path-sensitive就直接考虑data dependence path condition. 这里我引入了特殊的约束条件$\phi(s_i,s_j)$是有必要的，因为statement能否正确的执行也需要一定的约束条件, i.e. $z = x/y \Rightarrow y \neq 0$. 我这里关于path-sensitive sparse analysis的定义和原文有一点区别，原文一个$\prod$保存了所有data dependence paths，似乎最后把它们聚合到一起来作为整体data dependence path conditions，我有点不理解. 因此我把关系每个结点的data dependence paths分开放置，这样后面对某一点进一步分析的时候，我们可以只关注相关的data dependece path.  
\end{annotation}

\begin{definition}
\rm  
\end{definition}


\end{document}
